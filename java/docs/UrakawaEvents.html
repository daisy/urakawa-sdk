<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11-flat.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US"><head><style type="text/css">body {background-color: #ffffff; color:#333333;font-size:12px;font-family: "Lucida Grande", "Lucida Sans Unicode", verdana, lucida, arial, sans-serif;}.inlinenotes {background-color: #FFF280; padding: 2px;}.red {color: #ff0000;}.green {color: green;}</style><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Urakawa SDK: Events</title></head><body>

<hr />

<h1 id="theurakawasdk:eventframework">The Urakawa SDK: event framework</h1>

<hr />

<h1 id="events:why">Events: why ?</h1>

<p>During the development of the Obi application, programmers realized that in order to make their GUI views synchronize with the data model automatically, they had to write a lot of boiler-plate code. In essence, they had to write a full MVC-oriented architecture, without any direct support from the SDK.</p>

<p>In some instances, they even had to re-write core methods of the data model in order to insert their own mechanisms to raise events before and after changes occur. A prime example is when de-serializing a project file written in the XUK XML language: operations in the XUK-in methods needed to be intercepted, in order to build some internal data structure on-the-fly. This obviously, breaks encapsulation and is not a good practice.</p>

<p>As a result, an emerging requirement was to have some form of event mechanism (notification messaging) provided internally, by the SDK, so that application developers can simply connect their components to listen to events occurring whenever the state of the data model changes.</p>

<h1 id="challenges">Challenges</h1>

<h2 id="raiseevents:when">Raise events: when ?</h2>

<p>Events should be raised only for each low-level operation provided by the toolkit. For complex operations (usually convenience methods) that perform a sequence of "atomic" low-level operations, there should not be any event raised other than the ones raised by the delegate lower-level operations. Otherwise, the event receivers (e.g. registered listeners) would receive redundant and confusing information.</p>

<p>This means that event types and possible event instances have to be carefully designed, to be a minimal but complete set of state-change events, able to handle any possible modification of the data model.</p>

<h2 id="raiseevents:how">Raise events: how ?</h2>

<p>To summarize, events can be raised in 2 different ways:</p>

<ol>
<li>Event instance <br />
A notification event can be raised by literally creating an object instance, and by letting a dispatcher do the job of sending the instance to registered receivers ("listeners"), in sequence. If an event bus  is used instead of a dispatcher, the concept of a single event instance being passed along remains the same.</li>
<li>Method callback <br />
Another way of communicating state change is by calling methods of which the signatures (return type and more importantly, passed parameters) represent the type of change that occurred. In this context, a receiver is an object instance of a class that implements this method.</li>
</ol>

<p>Both methods allow 1 event to be notified to many receivers, based on a registration mechanism. Nevertheless, method 1 is largely preferred, because it allows to encapsulate the state of the event (e.g.: "cancel" flag, see below) in an Object-Oriented way. This allows a hierarchy of event types, and a extensible event framework based on a generic event type (important requirement, given that the Urakawa data model is totally extensible).</p>

<h3 id="memoryimplications">Memory implications</h3>

<p>With such scenario, each event corresponds to a data structure in memory. It is very likely that many events are propagated during an authoring session, so there are memory (de-)allocation issues to be considered. When the event is propagated, receivers should ensure to not keep a strong reference to the event, otherwise it would no be garbage-collected (with Java, C#, etc.). For language platforms without garbage collection, the problem demands even more attention.</p>

<h3 id="executionflowimplications">Execution flow implications</h3>

<p>Another important point is that event propagation is synchronous, in the sense that the source component ("emitter", "producer") which raises the notification event, waits until all destination components ("receivers", "consumers") have processed the message. This is why consumers should spend as little time as possible processing the event. Any lengthy operation as a result of receiving an notification event should be executed in a separate thread, to let the event dispatcher regain control.</p>

<h3 id="eventsandthecancelflag">Events and the "cancel" flag</h3>

<p>One concept found in the C#.NET event framework is the ability to mark an event as "cancelled", so that when the emitter (which raised the event) gains control of the execution flow again (remember, event propagation is synchronous), it is able to test the "cancel" flag on the event and stop the current algorithm process, if necessary.</p>

<p>A concrete use-case in the context of the SDK is to have "pre" and "post" events, generated just before and after an atomic data model operation is performed, respectively. The "pre" notification event can "be cancelled" by any receiver/listener.</p>

<p>Our first experimentations will not include such concept, because the user-case identified in Obi was primarily derived from an error in the application design.</p>

<h1 id="knowndesignpatterns">Known design patterns</h1>

<p>We are mainly interested in 3 types of design patterns:</p>

<ol>
<li>The <strong>Observer</strong> pattern</li>
<li>The <strong>Listener</strong> pattern</li>
<li>The <strong>EventBus</strong> pattern</li>
</ol>

<p>Complete descriptions of these design patterns are available, but here are the main differentiators:</p>

<ol>
<li>The <strong>Observer</strong> pattern <br />
Observers are notified when the state of the Subject changes, but this is not fine-grained: it is impossible to register to a specific type of change. Observers therefore get notified of any change occurring in the data model, which presents a significant overhead.</li>
<li>The <strong>Listener</strong> pattern <br />
As opposed to the Observer pattern, this design allows for registering listeners to particular types of events. One direct implication is that there can be many different event types, so this represents a bigger architectural challenge.</li>
<li>The <strong>EventBus</strong> pattern <br />
This pattern reduce inter-module dependencies by providing a bus which supports a generic event type. Event propagation from the emitter perspective only consists in sending an event on the bus, while ignoring completely how it is received and processed by the various destinations points on the bus.</li>
</ol>

<p>Our first experimentations will rely on the Listener pattern.</p>

<h2 id="listenerpatternremarks">Listener Pattern remarks</h2>

<p>There is one important guideline for when using this type of event framework:
registerListener() and unregisterListener() should always work in pairs ! (otherwise there are obvious memory allocation issues, garbage collection or explicit ref-count)</p>

<p>It is not uncommon that between these 2 calls, operations may raise unchecked exceptions. A good method is to use the "finally" clause to ensure the listener is unregistered before leaving the current scope (e.g. method).</p>

<h1 id="architecturalimplications">Architectural implications</h1>

<ol>
<li>The Urakawa data model is essentially a tree structure made of CoreNodes and Properties. State-change events related to the data model will therefore be implemented at the level of CoreNodes and Properties.</li>
<li>Events are native to the core of the SDK, therefore CoreNodes and Properties support events by design, they depend on the Event framework. In other words, calls to modification methods always try to generate events (if there are no registered listeners, there is no need to create event instances, so this is a possible optimization).</li>
<li>On the other hand, application developers can ignore the event messaging system if they do not need it. They simply do not register any listener, in which case the data model should be "clever" enough not to generate useless event instances.</li>
<li>Application developers can re-use the Event framework independently from the Urakawa data model, in their own data model.</li>
<li>The objective of the Command framework is to provide an easy way to execute and register operations from the application domain. This is an extremely convenient pattern to implement an UndoRedo manager. Depending on how the Event framework is implemented, there might be some overlap here (commands encapsulate operations on the data model, events encapsulate notifications of changes on the data model).</li>
</ol>

<hr />

<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml11" alt="Valid XHTML 1.1" style="border:0;width:88px;height:31px;"/></a><a href="http://jigsaw.w3.org/css-validator/check/referer"><img style="border:0;width:88px;height:31px;" src="http://jigsaw.w3.org/css-validator/images/vcss" alt="Valid CSS"/></a></p>

<div style="height: 600px;">&nbsp;</div>

</body></html>