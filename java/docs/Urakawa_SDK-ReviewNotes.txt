Urakawa SDK
Review Notes for both the design and the C# implementation.

Last modification by Ole Holst Andersen on October 28 2007

1) Global review of method visibility/accessibility (new, override, virtual, final, abstract, etc...).

6) Verify the mergeWith, split and copy-clipped methods, on AudioMediaData (or its direct container ManagedAudioMedia), on WavClip, and with different return types (Stream, AudioMediaData, etc.).
** Ole: DONE

6-a) Comments about the implications of use of the copy() method for merge:

{
A = merge(B, C); // static function call
}

would be the equivalent of:

{
A = B.copy();
A.mergeWith(C.copy()); // object instance method call
}

=> B and C are untouched.

=> B.copy() and C.copy() are newly allocated clone instances, so we need to be careful:

C.copy() should be short-lived (the "copy" method creates a "new" object on the memory heap and returns it):

=> in C# (and Java, etc.) = quickly garbage-collected, assuming there is no external strong / weak reference to / from the instance created by the C.copy() method call.

=> in C++, we have to be more careful, because if C.copy() returns an object instance allocated with "new", we need a matching "delete":

{
A = B.copy();
D = C.copy();
A->mergeWith(D);
delete D;
}

13-c) Add isManagerOf(uid:string):bool methods to the managers
** Ole: DONE

21) Ole, in the Presentation constructor comments, could you please specify that a default root node is created ? I know getRootNode() cannot return null, but it would be nice to let the toolkit user know at the level of the Presentation constructor(s).
** Ole: DONE

example:
getPresentation().getRootNode().appendChild(node);



24) How to interpret the UML graphics:

a) the "boxes" are UML entities, here they can be: class, abstract class, interface.

b) the box colors are simply here to differentiate packages (functional scope). e.g.:
green = media.data
pink = media.data.audio
light-gray/blue-ish = a lollypop to an external domain (here: the media package)

c) Arrows
- with closed tip (always gray):
	- solid: class EXTENDS another_class (can be abstract)
	- dashed: class IMPLEMENTS interface

- with open tip (always dashed, has a text label so we don't rely only on color):
	- green: aggregation relationship
	- red: composition relationship
	- blue: factory creation of instances
	- gray: clone / copy of instances

27) Daniel noticed that Implementation's create() factory methods must register new object to the manager, if any.
** Daniel: DONE

Ole's reply:

* ChannelFactory create methods does not (as you correctly observed) add
the created Channel to the associated ChannelsManager

* MediaDataFactory create methods does not add the created MediaData to
the associated MediaDataManager

* FileDataProviderFacotory create methods does add the created
FileDataProvider to the associated FileDataProviderManager, although
this is done on the internal FileDataProvider constructor.

Shall I fix all 3 cases so they all add their creations to the
respective managers?

Daniel's reply:

Note: bare in mind, I am a partisan of the separation of construction and initialization phases (it's a design pattern that solves a lot of problems, without adding too many ;) ). So for me, an empty / no-arg / partial constructor is totally viable.

-------------------------------------------------------------------------

// The factory
public class ManagedObjectFactory {
	...
	public Manager getPresentation() {
		// The Presentation owns this ManagedObjectFactory,
		// and we keep a back-track reference here.
		return mPresentation;
	}
	...
	public Manager getManager() {
		// The Presentation actually owns the Manager,
		// so we delegate.
		return getPresentation().getManager();
	}
	...
	public ManagedObject createManagedObject() {

		// constructed but not yet initialized properly.
		ManagedObject object = new ManagedObject();

		// see the class below: we complete the initialization of the object.
		getManager().manage(object);

		// we return a fully managed object.
		return object;
	}
	...
}

// The manager
public class Manager {
	...
	List<ManagedObject> localList;
	...
	public void manage(ManagedObject object) {

		// this manager now owns the object.
		localList.add(object);

		// call to initialization method,
		// to set the back-track reference.
		object.setManager(this);
	}
	...
}

-------------------------------------------------------------------------

28) "new" and "virtual" C# keywords:

"virtual" never calls the 'super' method.

Daniel:
We should also be careful with operator precedence !
The "." has a higher precedence order than the "(type)" explicit cast operator (aka "explicit type promotion").

XmlProperty xmlProp;

Property prop = xmlProp;

XmlProperty xmlPropCopy = (XmlProperty)prop.copy();

...is identical to:

Property xmlPropCopy = (XmlProperty)(prop.copy());

but different than:

Property xmlPropCopy = ((XmlProperty)prop).copy();

Only the above line of code return the correct xmlPropCopy.

It is interesting to note that it would work with interfaces:

iProperty prop = xmlProp;
(XmlProperty)prop.copy();

or:

(XmlProperty)((iProperty)prop).copy();

This is how interfaces should be used: not to infer / coerce a type, but to narrow the scope in the set of methods that define public interface to the type.

31) Have several Presentations per Project
** Daniel: TODO

32) Discuss the metadata current design => is it generic enough for RDF, etc., or is it bound with XHTML

32-a) Metadata add LocalName + Namespace support + "optionalAttribute" should simply be "attribute"
** Daniel: DONE

34) XmlProperty => remove XmlType.
** Daniel: DONE
** Ole: DONE

35) Add "language" attribute to Presentation+Channel+Media
** Daniel: DONE
** Ole: Done

36) Remove MediaType + Channel.isMediaTypeSupported(MediaType) (replace with Channel.canAccept(Media)) + remove Channel.addSupportedMediaType() + remove MediaTypeIsNotSupportedException + fix SequenceMedia.canAccept(Media) + add TypedSequenceMedia(<Media>) + fix factory createMedia() (for each media type including empty sequence)
** Daniel: DONE

40) Presentation.cleanup() (Project.cleanup() calls Presentations.cleanup())
** Daniel: DONE

41) XUK not compatible from C# Impl to C++ Impl (for example). Because of internal implementation details, like non-destructive authoring (WavClip) in C#. XUK header should contain URI to where to find the SDK implementation that produced the XUK and/or is able to open it. It should also contain the version number or a more complete identifier. Obi's XUK format also contains additional URL and namespace definition for custom extensions (e.g. SectionNode, PhraseNode).

42) WavAudioMediaData.forceSingleDataProvider()  belongs there because it is an implementation-specific feature (WavClip exists for non-destructive authoring, which the SDK design does not mandate/specify: it could potentially be implemented differently for MP3 codec, for example)

46) @Daniel: add ManagedMedia interface:
ManagedAudioMedia implements AudioMedia, ManagedMedia;
** Daniel: DONE
** Ole: DONE

47) Presentation.enableUndoRedo() + Presentation.disableUndoRedo() (default is NOT enabled)
** Daniel: DONE

47a) Remove the above two methods from Presentation, as they are no longer needed since auto command generation was abandoned (see 53))
** Ole: DONE - was never in implementation

48) Undo-Redo Transaction
UndoRedoManager.startTransaction() + UndoRedoManager.endTransaction() + UndoRedoManager.cancelTransaction()
** Daniel: DONE
** Ole : DONE - not tested

48a) Review comments in architecture UndoRedoManager: The comments on startTransaction states that commands executed after normally whereas endTransaction states that 

49) Mark methods that change the data model and register commands (e.g. WriteOnlyTreeNodeMethods).
Use a UML stereotype and add comments. Implementation: check Presentation.isUndoRedoManagerActive() to call the appropriate code (i.e. direct access to the data model / construct a command and register + execute)
Also add the corresponding command classes (e.g. Command_TreeNodeAdded).

50) Have Property implement WithPresentation
** Ole: DONE

51) Command is missing method bool: canUnExecute()
DANIEL: lots of todo here ! (wrong comments, missing exceptions, etc.)

52) Add int getCount() and void append(ICommand cmd) and List<ICommand> getListOfCommands() methods to CompositeCommand
** Ole: DONE

54) application access of undo/redo stack content (list of commands) => gives getDescription() to display GUI list for direct selection of undo of redo level
** Ole: DONE - by adding methods getListOfUndoStackCommands, getListOfRedoStackCommands, getListOfCommandsInCurrentTransaction

55) TreeNode.setAudioMedia(audioMedia),
TreeNode.setTextMedia(textMedia) => convenience (default channels for these media types, automatic creation of all required stuff: ChannelsProperty, AudioChannel registration to ChannelManager)
AudioChannel ChannelManager.set/getDefaultAudioChannel(c)
TextChannel ChannelManager.set/getDefaultTextChannel(c)

56) In architecture, TreeNodeImpl has a setProperty method that should have been removed in the Property assignment refactoring
** Ole: DONE (there was nothing to do)

57) Remove XmpProperty.copyXmlProperty and ChannelsProperty.copyChannelsProperty in architecture?
** Ole: DONE (there was nothing to do)

58) Add method getListOfUsedMediaData to UndoRedoManager that returns a list of all MediaData used by a command associated with the UndoRedoManager via. the undo/redo stacks or via. the currently active transaction
** Ole: DONE

59) Change IXukAble.XukOut method by adding Uri baseUri parameter. Previously the baseUri of Presentation was used, but this solutions was never clean and works even worse with multiple Presentations per Project.

60) Rename Presentation.get/setBaseUri to get/setRootUri to avoid confusion with baseUri of XukOut.

61) Ole: remove Project(bool initialize) + addNewPresentation();