Urakawa SDK
Review Notes for both the design and the C# implementation.

Last modification by Daniel WECK on 03 July 2007

1) Global review of method visibility/accessibility (new, override, virtual, final, abstract, etc...).

6) Verify the mergeWith, split and copy-clipped methods, on AudioMediaData (or its direct container ManagedAudioMedia), on WavClip, and with different return types (Stream, AudioMediaData, etc.).
** Ole: DONE

6-a) Comments about the implications of use of the copy() method for merge:

{
A = merge(B, C); // static function call
}

would be the equivalent of:

{
A = B.copy();
A.mergeWith(C.copy()); // object instance method call
}

=> B and C are untouched.

=> B.copy() and C.copy() are newly allocated clone instances, so we need to be careful:

C.copy() should be short-lived (the "copy" method creates a "new" object on the memory heap and returns it):

=> in C# (and Java, etc.) = quickly garbage-collected, assuming there is no external strong / weak reference to / from the instance created by the C.copy() method call.

=> in C++, we have to be more careful, because if C.copy() returns an object instance allocated with "new", we need a matching "delete":

{
A = B.copy();
D = C.copy();
A->mergeWith(D);
delete D;
}

13-a) *Manager.detach*() verify normalize naming convention for Managers (e.g. add/remove). ==> for MediaDataManager, ChannelsManager, DataProviderManager.
For DataProviderManager, the remove methods take a new parameter to specify whether to destroy ("delete") the actual binary resource (e.g File).
** Daniel: DONE

13-b) ChannelsManager.getListOfChannelsByName() ==> rename by removing "ByName"
** Daniel: DONE

17) new package hierarchy: urakawa.media.data.audio.codec instead of urakawa.media.data.codec.audio
urakawa.media.data.audio now contains some audio-specific stuff that should not be mixed with generic stuff in urakawa.media.data
** Daniel: DONE
** Ole: DONE

18-a)
* I would simplify getExecuteShortDescription()/getUnexecuteShortDescription() into a single getShortDescription() function returning a string that is suitable in the contexts of "Undo {short description}" and "Redo {short description}".
** Daniel: DONE

21) Ole, in the Presentation constructor comments, could you please specify that a default root node is created ? I know getRootNode() cannot return null, but it would be nice to let the toolkit user know at the level of the Presentation constructor(s).

example:
getPresentation().getRootNode().appendChild(node);

22) Copy tree structure across Presentations/Projects (with different factories, managers, etc.):
** Daniel: DONE

SOLUTION:


TreeNode {

	public virtual TreeNode export(Presentation destPres) throws FactoryCannotCreateTypeException {
		TreeNode newNode = destPres.getTreeNodeFactory().createNode(this.getXukLocalName(), this.getXukNamespace());

		if (newNode = null) { throw new FactoryCannotCreateTypeException() }

			List<Property> props = sourceNode.getListOfProperties();
			foreach (prop in props) {
				Property newProp = prop.export(destPres);
				newNode.addProperty(newProp);
			}
			foreach (childNode in getListOfChildren()) {
				newNode.appendChild(childNode.export(destPres));
			}
			return newNode;

	}
}

Property {
	public virtual Property export(Presentation destPres) throws FactoryCannotCreateTypeException {
		Property prop = destPres.getPropertyFactory().createProperty(this.getXukLocalName(), this.getXukNamespace());

		if (prop = null) { throw new FactoryCannotCreateTypeException() }
		return prop;
	}
}

ChannelsProperty extends Property {
	
	public override Property export(Presentation destPres) throws FactoryCannotCreateTypeException {
		
		ChannelsProperty destProp = (ChannelsProperty) super.export(destPres);
		
		ChannelsManager destManager = destPres.getChannelsManager();
		///ChannelsManager sourceManager = getPresentation.getChannelsManager();

		List<Channel> channels = this.getListOfUsedChannels();
		
		foreach (channel in channels) {	
			
			Channel destChannel = destManager.getEquivalentChannel(channel);
			
			
			if (destChannel == null) {
				destChannel = channel.export(destPres);
				// destManager.add(destChannel); // NO NEED TO DO THIS: because the above export() uses the factory create method, and therefore handles the association of the channel with its manager.
			}
			
			Media media = getMedia(channel);
			Media destMedia = media.export(destPres);

			destProp.setMedia(destChannel, destMedia);
		}
		
		return destProp;
	}
}

Media {
	public Media export(Presentation destPre)throws FactoryCannotCreateTypeException ;
}

ManagedAudioMedia implements ManagedMedia, AudioMedia {
	public Media export(Presentation destPre) throws FactoryCannotCreateTypeException {
		Media destMedia = destPres.getMediaFactory().createMedia(this.getXukLocalName(), this.getXukNamespace());
		if (destMedia = null) {throw new  FactoryCannotCreateTypeException()}
		
		ManagedAudioMedia destManagedMedia = (ManagedAudioMedia)destMedia;
.
		MediaData mediaData = getMediaData();
		MediaData destMediaData = mediadata.export(destPres);
		destManagedMedia.setMediaData(destMediaData);
	}
}


MediaData {
	public MediaData export(Presentation destPre)throws FactoryCannotCreateTypeException;
}

AudioMediaDataAbstractImpl implements MediaData {
	public MediaData export(Presentation destPre)throws FactoryCannotCreateTypeException {
		MediaData destMediaData = destPres.getMediaDataFactory().createMediaData(this.getXukLocalName(), this.getXukNamespace());
		if (destMediaData = null) {throw new  FactoryCannotCreateTypeException()}
		
		AudioMediaDataAbstractImpl destAudioMediaData = (AudioMediaDataAbstractImpl)destMediaData;
		destAudioMediaData.getPCMInfo().setSampleRate(getPCMInfo().getSampleRate());
		... same for noc+bit depth
		Stream dataStream = getAudioData();
		try {
			destAudioMediaData.appendAudioData(dataStream, getDuration());
		} finally {
			dataStream.close();
		}
	}
}

ChannelsManager {
	public Channel getEquivalentChannel(Channel sourceChannel) {
		foreach (thisChannel in getListOfChannels()) {
			if (thisChannel.isEquivalentTo(sourceChannel)) {return thisChannel;}
		}
		return null;
	}
}

Channel {
	public virtual boolean isEquivalentTo(Channel otherChannel) {
		if (!otherChannel.isSameTypeOf(this)) {return false;} // ZZ1
		if (otherChannel.getName() != getName()) {return false;}
		return true;
	}
}
	DanielChannel {
		Date mDate;
		
		public override boolean isEquivalentTo(Channel otherChannel) {
			
			if (! super.isEquivalent()) {return false;}
			
			DanielChannel ch = (DanielChannel)otherChannel; // Guaranteed to work because of line ZZ1 above
			if (ch.getDate() != getDate()) {return false;}
			return true;
		}
	}


	DateNode extends TreeNode {
		Date mDate;
		public override TreeNode export(Presentation destPres) throws FactoryCannotCreateTypeException {
			TreeNode newNode = super.export(destPres);
			if (! newNode instanceof this.getClass()) {
				throw new FactoryCannotCreateTypeException();
			}
			DateNode actualNode = (DateNode) newNode;
			actualNode.setDate(mDate);
			// etc...
			return actualNode;
		}
	}

Presentation {

static main(args) {
	Presentation presA;
	Presentation presB;
	
	TreeNode importedNode = presB.getRootNode().export(presA);
	
	presA.setRootNode(importedNode);
	// OR:
	presA.getRootNode().appendChild(importedNode);
}
}



24) How to interpret the UML graphics:

a) the "boxes" are UML entities, here they can be: class, abstract class, interface.

b) the box colors are simply here to differentiate packages (functional scope). e.g.:
green = media.data
pink = media.data.audio
light-gray/blue-ish = a lollypop to an external domain (here: the media package)

c) Arrows
- with closed tip (always gray):
	- solid: class EXTENDS another_class (can be abstract)
	- dashed: class IMPLEMENTS interface

- with open tip (always dashed, has a text label so we don't rely only on color):
	- green: aggregation relationship
	- red: composition relationship
	- blue: factory creation of instances
	- gray: clone / copy of instances

27) Daniel noticed that Implementation's create() factory methods must register new object to the manager, if any.
** Daniel: DONE

Ole's reply:

* ChannelFactory create methods does not (as you correctly observed) add
the created Channel to the associated ChannelsManager

* MediaDataFactory create methods does not add the created MediaData to
the associated MediaDataManager

* FileDataProviderFacotory create methods does add the created
FileDataProvider to the associated FileDataProviderManager, although
this is done on the internal FileDataProvider constructor.

Shall I fix all 3 cases so they all add their creations to the
respective managers?

Daniel's reply:

Note: bare in mind, I am a partisan of the separation of construction and initialization phases (it's a design pattern that solves a lot of problems, without adding too many ;) ). So for me, an empty / no-arg / partial constructor is totally viable.

-------------------------------------------------------------------------

// The factory
public class ManagedObjectFactory {
	...
	public Manager getPresentation() {
		// The Presentation owns this ManagedObjectFactory,
		// and we keep a back-track reference here.
		return mPresentation;
	}
	...
	public Manager getManager() {
		// The Presentation actually owns the Manager,
		// so we delegate.
		return getPresentation().getManager();
	}
	...
	public ManagedObject createManagedObject() {

		// constructed but not yet initialized properly.
		ManagedObject object = new ManagedObject();

		// see the class below: we complete the initialization of the object.
		getManager().manage(object);

		// we return a fully managed object.
		return object;
	}
	...
}

// The manager
public class Manager {
	...
	List<ManagedObject> localList;
	...
	public void manage(ManagedObject object) {

		// this manager now owns the object.
		localList.add(object);

		// call to initialization method,
		// to set the back-track reference.
		object.setManager(this);
	}
	...
}

-------------------------------------------------------------------------

28) "new" and "virtual" C# keywords:

"virtual" never calls the 'super' method.

Daniel:
We should also be careful with operator precedence !
The "." has a higher precedence order than the "(type)" explicit cast operator (aka "explicit type promotion").

XmlProperty xmlProp;

Property prop = xmlProp;

XmlProperty xmlPropCopy = (XmlProperty)prop.copy();

...is identical to:

Property xmlPropCopy = (XmlProperty)(prop.copy());

but different than:

Property xmlPropCopy = ((XmlProperty)prop).copy();

Only the above line of code return the correct xmlPropCopy.

It is interesting to note that it would work with interfaces:

iProperty prop = xmlProp;
(XmlProperty)prop.copy();

or:

(XmlProperty)((iProperty)prop).copy();

This is how interfaces should be used: not to infer / coerce a type, but to narrow the scope in the set of methods that define public interface to the type.

29) Should the Undo-Redo Manager be stored in XUK ? (Command and UndoRedoStackManager Xukable)
It would be good, because chunks of audio maintained for example by the MediaDataManager must be kept "alive" while there is a possibility to undo an operation. Obviously if the undo-redo history is flushed, then the corresponding data can be freed. If a user closes a project, the data stays in the directory anyway, so it would be a shame not to save the undo-redo-history in the XUK. BEWARE: a "cleanup" operation must NOT delete data that's still bound to a Command in the undo-redo manager.
** Daniel: DONE

30) Move metadata to presentation
** Daniel: DONE

31) Have several Presentations per Project
** Daniel: DONE

32) Discuss the metadata current design => is it generic enough for RDF, etc., or is it bound with XHTML

32-a) Metadata add LocalName + Namespace support + "optionalAttribute" should simply be "attribute"
** Daniel: DONE

33) SDK 2.x fundamental change = several properties of the same type per TreeNode. We want to move this to 1.0 while there is only one user base (Obi). Then we remove the issues of backward compatibility.
** Daniel: DONE

Property {
	+ boolean canBeAddedTo(TreeNode);
}

Property prop1 = Factory.create();
TreeNode tree1;
TreeNode tree2;

TODO: check ownership !
tree1.addProperty(prop1); // from then on, prop1 belongs to tree1
tree2.addProperty(prop1); // prop1 is already "owned" so this raises an exception

FlagProperty extends Property {+String}


ErrorProperty extends AnnotationProperty
WarningProperty extends AnnotationProperty

List<T> = TreeNode.getListOfProperties(T);

List<FlagProperty> = TreeNode.getListOfProperties(<FlagProperty>);

List<ErrorProperty> = TreeNode.getListOfProperties(<ErrorProperty>);
List<WarningProperty> = TreeNode.getListOfProperties(<WarningProperty>);

List<ChannelsProperty> = TreeNode.getListOfProperties(<ChannelsProperty>);
==> the list, by design, only has 1 element.

typeof(Type)
Type.class

WarningProperty = TreeNode.getProperty(<WarningProperty>);
==> returns one amongst the list, random one (not guaranteed to be the first, whatever)

List<Property> = TreeNode.getListOfProperties();

TreeNode.addProperty(Property);
TreeNode.addProperties(List<Property>);

TreeNode.removeProperty(Property);
List<Property> = TreeNode.removeProperties(<Property>);
TreeNode.removeProperties();.

TreeNode.hasProperties(<Property>);
TreeNode.hasProperty(Property);
TreeNode.hasProperties();

34) XmlProperty => remove XmlType.
** Daniel: DONE

35) Add "language" attribute to Presentation+Channel+Media
** Daniel: DONE

36) Remove MediaType + Channel.isMediaTypeSupported(MediaType) (replace with Channel.canAccept(Media)) + remove Channel.addSupportedMediaType() + remove MediaTypeIsNotSupportedException + fix SequenceMedia.canAccept(Media) + add TypedSequenceMedia(<Media>) + fix factory createMedia() (for each media type including empty sequence)
** Daniel: DONE

37) move org.daisy.urakawa.core.property to org.daisy.urakawa
	move org.daisy.urakawa.properties.* to org.daisy.urakawa.property.*
** Daniel: DONE

39) Command: getListOfUsedMediaData() (for cleanup)
** Daniel: DONE

40) Presentation.cleanup() (Project.cleanup() calls Presentations.cleanup())
** Daniel: DONE

41) XUK not compatible from C# Impl to C++ Impl (for example). Because of internal implementation details, like non-destructive authoring (WavClip) in C#. XUK header should contain URI to where to find the SDK implementation that produced the XUK and/or is able to open it. It should also contain the version number or a more complete identifier. Obi's XUK format also contains additional URL and namespace definition for custom extensions (e.g. SectionNode, PhraseNode).

42) WavAudioMediaData.forceSingleDataProvider()  belongs there because it is an implementation-specific feature (WavClip exists for non-destructive authoring, which the SDK design does not mandate/specify: it could potentially be implemented differently for MP3 codec, for example)

43) Fix ManagedMedia->composition->MediaData + MediaData->Composition->DataProvider
** Daniel: DONE

44) ImageMedia rename to ExternalImageMedia
** Daniel: DONE

45) replace ChannelFactory.create(String name) with ChannelFactory.create()
** Daniel: DONE

46) @Daniel: add ManagedMedia interface:
ManagedAudioMedia implements AudioMedia, ManagedMedia;
** Daniel: DONE

47) Presentation.enableUndoRedo() + Presentation.disableUndoRedo() (default is NOT enabled)
** Daniel: DONE

48) Undo-Redo Transaction
UndoRedoManager.startOperation() + UndoRedoManager.endOperation() + UndoRedoManager.cancelOperation()
** Daniel: DONE

49) Mark methods that change the data model and register commands (e.g. WriteOnlyTreeNodeMethods).
Use a UML stereotype and add comments. Implementation: check Presentation.isUndoRedoManagerActive() to call the appropriate code (i.e. direct access to the data model / construct a command and register + execute)
Also add the corresponding command classes (e.g. Command_TreeNodeAdded).