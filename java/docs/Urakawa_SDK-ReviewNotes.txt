Urakawa SDK
Review Notes of both design and C# implementation.

>>
Remarks by OHA, 30-05-2007
<<

-- things to consider changing in both design and C# impl. --

static getXukLocalName()/getXukNamespaceUri()

getXukQName() in addition to the separate methods ?

CorePropertyFactory should be abstract (at least in the design), because Java does not have the "virtual" keyword for:
public virtual IProperty createProperty(string localName, string namespaceUri)
(which always return null, so needs to be implemented anyway)
>>OHA
I have made an implementation of IProperty called Property that is not abstract and I have changed CorePropertyFactory so that it can now create Property instances. The reason for having Property be a concrete class is that an Application could choose to use subclasses of Property with no added functionality as flags (MyFlagProperty : Property with no added functionaity)
<<

iAudioMediaData:
Stream getAudioData(ITime clipBegin, ITime clipEnd);
that's ok, but we also need:
iAudioMediaData copyClipped(ITime clipBegin, ITime clipEnd); // (because of copy() analogy)
void splitAt(ITime splitPoint);
void mergeWith(iAudioMediaData);
>>OHA
We could consider using IAudioMedia copy(ITime clipBegin, ITime clipEnd); instead of copy clipped. Additionally I could see the use of the following method:
<<


XukIn/XukOut: instead of returning boolean, use exceptions.
In design, only one that wraps SDK-specific (actually, XML parser/writer specific) exception.
e.g.: XukException(String) or XukException(Object) or XukException(Exception) (the last one is best IMO)
>>OHA
I agree that this is needed, but since IXukAble is implemented by many classes this will take some time to change.
<<


Convenience factory methods on iPresentation, rather than having to query the get*Factory() first...and then 


iPresentation needs a set*Factory() to avoid using the constructor with many parameters (to override default factory).


MediaDataAbstractImpl and AudioMediaDataAbstractImpl: partial default implementation OK, but can we have intermediate interfaces to define a contract, or are we happy to just provide the partial implementation ?


PropertyAbstractImpl class, to provide a default implementation for get/setOwner().
IXmlProperty and IChannelsProperty are the built-in properties in the SDK implementation, which can be used directly via their concrete classes.
For custom properties, application developers can provide classes that implement IProperty, or that extend PropertyAbstractImpl. I don't mind either way.

	---8<---------
public abstract class PropertyAbstractImpl {

	public abstract IXmlProperty copy();

	public void setOwner(ICoreNode newOwner)
	{
		if (newOwner == null)
		{
			throw new exception.MethodParameterIsNullException("The owner core node can not be null");
		}
		mOwner = newOwner;
	}

	public ICoreNode getOwner()
	{
		return mOwner;
	}
}
	---8<---------



Implementation-only:

1) CoreNode.XukOut using Visitor instead of regular parsing algorithm.
>>OHA
I do not see how a Visitor would help me during XukOut.
<<

2) The set/getName() methods in IChannel are documented as "local name", which I think should be refined into "human-readable name" or "display name". It is easily confused with the XUK local name.
>>OHA
Fixed
<<

3) Should we add a default implementation for the breadth-first visitor algorithm ?
Julien's pseudo-code:
	---8<---------
 acceptBreadthFirst(visitor)
  {
    queue = [this]
    while(queue is not empty) {
      node = remove first item in queue
      push children(node) in queue
      visitor.preVisit()
    }
  }
	---8<---------


4) In Obi, the "FormatTime_*" utility functions could go in SDK's "Time" object type, or at least in the "time" package. The "AudioMediaAsset::export()" methods should probably be implemented in the SDK as well (Stream persistence, writing binary audio files. "export" more priority than "cleanup").




-- differences between design and C# impl. --

SequenceMedia needs append() in the implementation (ok in design).

in MediaDataPresentation:
setMediaDataFactory vs MediaAssetPresentation

FileDataProviderManager extends DataProviderManager in design (interface, *then* implementing *Impl concrete class) => missing in C#.
Same with FileDataProviderFactoryImpl implements FileDataProviderFactory.
same with FileDataProvider extends DataProvider
same with ExternalAudioMediaImpl implements ExternalAudioMedia
same with ExternalTextMediaImpl implements ExternalTextMedia
same with Project

CorePresentation vs Presentation concrete implementations ??

CoreNodeAdditionRemovalManager + CoreNodeGenericChangeManager: decision about splitting the event bus and listener pattern ? Also, the C# implementation is very specific: why no register/unregister of listeners ??

public class FileDataProvider : IDataProvider
getDataFileRealtivePath()
"relative" typo

class FileDataProvider
public FileDataProviderManager getDataProviderManager()
in design: get*File*DataProviderManager()
otherwise conflict with:
DataProviderManager getDataProviderManager()

in class FileDataProviderFactory:
c#:
public FileDataProviderManager getDataProviderManager()
design:
FileDataProviderManager getFileDataProviderManager()
otherwise conflicts with:
DataProviderManager getDataProviderManager()


FileDataProviderManager
appendDataToProvider() is static: in utilities ? (currently not in design)
compareDataProviderContent() same as above.
detachDataProvider(IDataProvider provider) implementation incomplete (does not remove)

IDataProviderManager
why ?
IMediaDataPresentation get*MediaData*Presentation()
setPresentation(IMediaDataPresentation)


IXukAble
currently, only public XukIn() and XukOut()
how about XukInAttributes, XukInChild, XukOutAttributes, XukOutChildren (virtual ok in implementation, but how about design ? SHould they be in design at all ?)
also Child vs Children ??

IManagedAudioMedia
design:
AudioMediaData getAudioMediaData();
C#:
new IAudioMediaData getMediaData();
conflict with MediaData getMediaData()

media.data.utilites
== implementation-specific and therefore not in design.
e.g. : let's say Clip.cs is special to C#, so C++ impl. would not use:
protected class WavClip : Clip, IValueEquatable<WavClip>.
if WavClip is in XUK, it needs to be in design (?)


-- TODO in design --

check and add:
- method parameter checked exceptions (throw + @throw + @tagvalue)
- concrete class constructors + extra methods
- abstract classes extra methods
- @depend UML relationships
- get/set @initialize
- general comments
- IsNotInitializedException and IsAlreadyInitializedException...not sure about using these anymore.