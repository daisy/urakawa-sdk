<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11-flat.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US"><head><style type="text/css">body {background-color: #ffffff; color:#333333;font-size:12px;font-family: "Lucida Grande", "Lucida Sans Unicode", verdana, lucida, arial, sans-serif;}.inlinenotes {background-color: #FFF280; padding: 2px;}.red {color: #ff0000;}.green {color: green;}</style><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Urakawa Project - Software Development Kit - Programmer's Guide / Developer Primer</title></head><body>


[emailDanielWECK]: mailto:daniel.weck@gmail.com "Daniel WECK email"

[wwwDaisyPipeline]: http://www.daisy.org/projects/pipeline/ "www"

[wwwANT]: http://ant.apache.org/ "www"

[wwwGraphviz]: http://www.graphviz.org/

[wwwUMLGraph]: http://www.spinellis.gr/sw/umlgraph/ "www"

[wwwNetbeans]: http://www.netbeans.org/ "www"
[wwwEclipse]: http://www.eclipse.org/ "www"

[wwwIntelliJ]: http://www.jetbrains.com/ "www"

[wwwW3C-SMIL]: http://www.w3.org/AudioVideo/ "Synchronized Multimedia Integration Language - W3C homepage"
[wwwSMILRec]: http://www.w3.org/TR/SMIL2/ "SMIL W3C Recommendation"

[wwwUrakawaSDKAPIDoc]: http://urakawa.sourceforge.net/sdk/apidoc/ "www"
[wwwUrakawaSDKCSharpDoc]: http://urakawa.sourceforge.net/sdk/APIdoc.zip "www"
[wwwUrakawaUMLDiagrams]: http://urakawa.sourceforge.net/sdk/uml-diagrams/ "www"

[wwwUrakawaDaisyHome]: http://www.daisy.org/projects/urakawa/ "www"

[wwwUrakawaSFHome]: http://urakawa.sourceforge.net/ "www"
[wwwUrakawaObiHome]: http://urakawa.sourceforge.net/obi/ "www"
[wwwUrakawaMirrorDaisyForAll]: http://www.daisy-for-all.org/urakawa-sfmirror/ "www"
[wwwUrakawaMirrorDaisy]: http://www.daisy.org/projects/urakawa/sfmirror/home.html "www"

[wwwUrakawaSFProject]: http://sourceforge.net/projects/urakawa "www"

[wwwUrakawaSVNBrowse]: http://svn.sourceforge.net/viewvc/urakawa/ "www"
[wwwUrakawaSVNBrowseTrunkRoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/ "www"
[wwwUrakawaSVNBrowseArchUMLRoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/architecture/ "www"
[wwwUrakawaSVNBrowseArchJavaRoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/architecture/UMLGraph/src/org/daisy/urakawa/ "www"

[wwwUrakawaSVNBrowseArchIDEARoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/architecture/UMLGraph/ "www"

[wwwUrakawaSVNGuide]: http://sourceforge.net/svn/?group_id=149942 "www"

[wwwLGPL]: http://www.gnu.org/licenses/lgpl.html "www"

[wwwDublinCore]: http://dublincore.org/ "www"

-------------------

# The Urakawa Project
## Application Programming Interface / Software Development Kit
### Implementor's Guide / Developer Primer

_Author/Editor_ : [__Daniel WECK__][emailDanielWECK]  
_Last revision_ : __2007 August 06__

-------------------

# Table of Contents

1. [Introduction][]
  1. [Goal][]
  - [Project Organization][]
  - [UML Documentation][]
- [Key Concepts][]
 1. [Data Model Genericity][]
 - [Object Model Generalities][]
 - [Persistence with XUK][]
 - [Object Creation using Factories][]
 - [Condition Checking and Exceptions][]
- [Model Structure][]
 1. [Core][]
  1. [Navigation][]
  - [Events][]
 - [Commands, Undo-Redo][]
 - [Exceptions][]
 - [Metadata][]
 - [Navigator][]
 - [XUK][]
 - [Properties][]
  1. [XML][]
  - [Channel][]
 - [Media][]
  1. [Media Data][]
  - [Timing][]
 - [Examples][]
- [Glossary of Terms][]

-------------------

# Introduction

## Goal

The intended audience for this document is:

* designers / modelers of the SDK's data model and facade API.
* implementors of the Urakawa SDK (e.g. C++, Java, C#).
* application developers of software tools using / based-on the SDK.

The purpose of this manual is to:

* present a high-level architecture of the SDK data model.
* provide guidance for software programmers, in particular to facilitate application programming ("how to use the SDK").

This guide is __not__ a replacement for the "[API-doc][wwwUrakawaSDKAPIDoc]", which remains the recommended programmer's reference. Additional [UML class-diagrams][wwwUrakawaUMLDiagrams] offer some reading convenience (Unified Modeling Language).

This guide does __not__ provide information for language-specific SDK implementations. Instead, it describes the generic language-independent object-oriented model of the SDK. The SDK design is normally implemented as-is, modulo any language-specific optimizations. For implementation-specific details, please refer to the appropriate documentation (e.g. [C# SDK doc][wwwUrakawaSDKCSharpDoc]).

## Project Organization

The [Urakawa project][wwwUrakawaSFHome] (mirror available [here][wwwUrakawaMirrorDaisyForAll]) specifies an object-oriented __API__ (Application Programming Interface) and currently provides a reference implementation written in C# (__SDK__, Software Development Toolkit). A C++ reference SDK implementation is planned, please consult the website for more information.

The Urakawa project also hosts software applications that rely on the functionality provided by the SDK. __[Obi][wwwUrakawaObiHome]__ is a Daisy authoring tool (for audio NCX-only books). __Tobi__, a new software project that will become public soon, will also be based on the Urakawa SDK. It will facilitate authoring of full-text full-audio DTB (digital talking books).

All of the Urakawa project deliverables are published under an [open-source license][wwwLGPL]. Developers are strongly encouraged to checkout the project source code using Sourceforge's [SVN project repository][wwwUrakawaSVNGuide] (Subversion source code version control). Immediate online viewing is also available through the [SVN browser][wwwUrakawaSVNBrowse].

To reflect the aforementioned deliverables, the Urakawa project is conveniently divided into 3 main activities:

- "Architecture" => the SDK design (data model and facade API)
- "Implementation" => the SDK reference-implementation (currently C#)
- "Application" => a show-case application (currently Obi, later Tobi)

The source code and documents associated to these 3 modules are available in the SVN repository, in [distinct locations][wwwUrakawaSVNBrowseTrunkRoot] identified by their names.

In the present document, we will focus on the Architecture part of the project, for which the main deliverables (other than the present document) are essentially a set of UML class diagrams and a thoroughly documented abstract API.

## UML Documentation

The SDK's data model and facade API are specified in an Object-Oriented (OO) fashion. UML class diagrams are used to present the architecture of the software design.

The UML diagrams are [distributed][wwwUrakawaSVNBrowseArchUMLRoot] in the PNG image format, and are designed primarily to be viewed on the screen, and optionally to be printed-out on paper.

The UML diagrams are built using a plain-text declarative format. The design is therefore accessible to blind and visually impaired users. This source material is in fact plain Java code, augmented with special annotations used for generating the set of UML diagrams. Developers will probably prefer to work with the source code directly, rather than looking at static UML images. Please consult the [SVN repository][wwwUrakawaSVNBrowseArchJavaRoot] for more information.

Java was chosen as the declarative form of the UML diagrams, because of its strong focus on OOP (Object-Oriented Programming). However, the SDK design is not Java-only or Java-centric ! Any language that supports OOP can be used to implement the SDK. Language-specific optimizations and OO concepts can be used to taylor the implementation for a particular user-group.

There are very good IDEs (Integrated Development Environment) for the Java programming language, so the SDK design is very easy to write and navigate. 

Another benefit from using a declarative text format for the UML diagrams (instead of raw, flat images) is that the source material can be included under version control (e.g. SVN Subversion or CVS).As a result, the history of changes can be viewed using the standard "diff" tools, and updates can easily be reverted.

The UML diagrams production process involves a special parser for the Java sources, called [UMLGraph][wwwUMLGraph]. This tool produces "dot" files (plain-text declarative graph format) which are then interpreted by [Graphviz][wwwGraphviz] to output a variety of formats (PNG, PDF, HTML image maps, etc.). In order to supply detailed UML entity information, special UMLGraph annotations are used in the source Java code (in addition to the standard JavaDoc comment tags). The full process is implemented using the [ANT][wwwANT] makefile format, see the ["build.xml" file][wwwUrakawaSVNBrowseArchIDEARoot].

-------------------

# Key Concepts

## Data Model Genericity

Initially, the Urakawa project targets in priority DTB (Digital Talking Book) formats (e.g. Daisy), but the SDK potentially meets the requirements of many other use-cases, such as accessible motion pictures, general SMIL authoring, etc.

The data model provides a structure for generic multimedia presentations, in a modular and extensible way, to enable a variety of application domains. The API is not based on a specific authoring scenario, instead it provides a generic framework for manipulating multimedia documents.

Multimedia presentations based on the Urakawa data model are highly-structured documents, based on a central tree which supports enhanced navigation, timing, metadata, media objects (etc.), as well as custom (application-defined) constructs.

The approach used to implement such extensibility is to expose a generic document tree for which nodes can have a number of object "annotations" or "properties".

For example: a given tree node in the document is the structural equivalent of a "h1" HTML header, hosts an audio file for the human narration of the h1 text label, and is a navigable access point for the document's table of content. At authoring time, such h1 title may require further work by the document author, so an interesting edition facility is to have "todo" annotations inside the document tree which can be conveniently exposed in a dedicated UI view. In this case, an application-defined todo property can be attached to our h1 example node, via the extension mechanism provided by the underlying SDK. Generally speaking, any kind of data can be attached to a document tree.

## Object Model Generalities

The SDK design makes extensive use of interfaces to describe the object-oriented architecture. Interfaces provide service description (via a set of methods) as opposed to describing instance containers. They allow greater flexibility in respect to multiple inheritance (some languages do not support multiple inheritance, others do). W3C DOM is a prime example of the pervasive use of interfaces. IDL (Interface Definition Language) is also representative of the benefits of abstraction.

Concrete classes are often named "*Impl" (e.g. TreeNodeImpl), and have an equivalent base interface (e.g. TreeNode). This is because the SDK uses the factory design pattern to generate instances, in order to facilitate round-trip serialization into the Urakawa XML format (XUK). For more information, please refer to the appropriate sections in this document. Generally-speaking, a base interface can have several concrete implementations for which instances can be generated transparently by the factory methods. By default, the SDK provides single implementations but applications can extend this behaviour to meet their requirements (e.g. TreeNodeMobileDeviceImpl vs TreeNodeWebServerImpl). Implementations which do not wish to expose multiple realizations of a base interface my choose to exclude the base interface from their design and include the concrete class only. Base interfaces and are marked with the "@leafInterface" annotation, so they are easily identifiable as optional.

There is another type of optional interface in the Urakawa SDK design, which is provided only for reading convenience (splitting the design in distinct, smaller modules). Such interface is marked with the "@designConvenienceInterface" annotation. By contrast, other "normal" interfaces have a role to play to guarantee the extensibility of the data model, so they should remain in reference implementations.

Abstract classes are used when we explicitly want to limit the application developer's capacity to extend the design (in the object inheritance sense).

Interfaces cannot specify composition or aggregation relationships (in the UML "association" sense), but the SDK design uses a special UML notation to describe these relationships at the interface level (instead of at the level of the concrete classes). The motivation for this non-UML-standard addition is simply that *Impl concrete classes are usually not easy to read, because of the number of methods they contain. By placing the relationships at the level of the base interfaces, the Urakawa software design is a lot easier to understand and navigate. The resulting UML diagrams also benefit from the improved readability.

The Urakawa SDK (data model and API) is geared towards providing a clear design contract. Programming by contract not only facilitates unit-testing, it also removes ambiguities and clarifies expectations for developer teams.

For example, the Urakawa SDK design incorporates thorough checks of the values of method parameters. The assert conditions are described using checked exceptions for reading convenience, but of course strict implementation do not actually have to use exceptions at all (see the related chapter in the present document). The objective is to provide enough safeguards for preventing obvious (unfortunately common) implementation bugs.

UML associations such as aggregation and composition are extremely useful. They are an integral part of the design contract, by describing ownership relationship between object instances. This is useful information for implementations in languages that require manual memory handling (as opposed to virtual-machine-based, managed languages like Java and C#, with automatic garbage collection). For example, a C++ reference implementation must explicitly manage memory allocation (object ref-counting, etc.) to guarantee object integrity and prevent memory leaks.

## Persistence with XUK

The Urakawa SDK is based on a data model with native support for serialization in an XML format, called XUK. This provides authoring applications with a built-in mechanism ("out-of-the-box") for document persistence and allows for loss-less round-trip open/save operations.

XUK is an XML format for which the schema (grammar) is dependent on the application that uses the SDK (applications are likely to extend the default document model provided by the SDK). XML namespaces are used to distinguish between the default SDK serializable objects, and the custom application-specific types.

The "Xukable" interface is implemented by any object type that is serializable into the XUK format.

Support for importing and exporting other mainstream multimedia formats (e.g. Daisy, SMIL) is possible by converting to and from the XUK format. This is however out of scope for the SDK itself, so this functionality must be provided by third-party modules. The [Daisy Pipeline][wwwDaisyPipeline] provides transformers for many multimedia document types, and there are plans to develop support for the XUK format.

## Object Creation using Factories

The Urakawa API makes extensive use of factories for generating object instances (Factory Design Pattern).

This design choice stems from the requirements of round-trip serialization into the Urakawa XML format (XUK). A factory is able to generate an object instance based on a given type, specified by a fully qualified name (in the XML sense). As such, there is a direct mapping between element names in a XUK instance and object types in the data model.

Generally-speaking, a base interface can have several concrete implementations for which instances can be generated transparently by the factory methods. For example:
* TreeNode => base interface
* TreeNodeImpl => concrete implementation
* TreeNode TreeNodeFactory.createTreeNode(QName) => factory method

By default, the SDK provides single implementations but applications can extend this behaviour to meet their requirements (e.g. TreeNodeMobileDeviceImpl vs TreeNodeWebServerImpl).The default factories provided by the SDK can also be extended to support application-specific types.

As a result of this, not much emphasis is put on constructors in the SDK design. Instead, a fully constructed object is the result of its creation (using the factory) and of its initialization (by setting some required attributes). However, actual implementations may choose to expose constructors that take as many parameters as necessary to realize both creation and initialization at the same time (factory methods may also include more initialization parameters than specified in the design).

In fact, the whole initialization phase is a design-specific approach which is materialized my explicit setters (with matching getters). These methods tend to clutter the design, so for reading convenience they are usually extracted in a separate interface named "With*" (e.g. WithQualifiedName). Languages like C# provide native support for class attributes get and set methods, so implementors may choose not to expose explicit getters and setters. If so, special care should be taken to assert the conditions expressed in the SDK design (e.g. setName(String) "cannot pass a null or empty string value"). Note: setter methods that play a role in initializing object instances are marked with the "@stereotype Initialize" annotation. This stereotype actually appears in the resulting UML class diagrams as well.

## Condition Checking and Exceptions

Generally-speaking, exceptions should never be used for controlling the execution flow. The exceptions used in the Urakawa SDK design describe conditions for method input parameter values (e.g. boundaries for integers, null pointers, empty string values, etc.).

This is convenient for defining the implementation contract, but it does not mean that implementations have to use actual checked exceptions (they tend to have a negative impact on performance and require explicit try/catch/finally control structures). Instead, implementations may decide to use unchecked exceptions (ideal, as they generate full stack-trace reports), HRESULT values (very portable), or may choose not to return an error at all. The later is however not recommended, as asserting method parameter values can eliminate a great number of bugs, which are often difficult to trace if no adequate safeguard is implemented.

The UML class diagrams include a special annotation to visually represent the assertions on method parameter values.

-------------------

# Model Structure

The UML class diagrams (PNG images) are divided into several modules, which are carefully designed to enhance the reading experience. The goal is to present views of the architecture at various levels, and to remove unnecessary entities from diagrams that focus on particular characteristics of the data model.

The source material for the UML diagrams is the [Java source code][wwwUrakawaSVNBrowseArchJavaRoot]. This expression of the OO design contract is structured hierarchically, using standard Java "packages". As such, each package corresponds to a physical folder.

As a result, the SDK data model and facade API is easy to browse, using the user's preferred method (full-fledge Java IDE, command-line, text-editor, etc.). There are very good Java IDEs out there (e.g. Eclipse, Netbeans, IntelliJ IDEA, etc.), which provides quick keyboard navigation via their structured views. Blind and visually-impaired developers should be able to comfortably work with the SDK.

## Top-level

"_org.daisy.urakawa_" is the root package (or "namespace") of the project. It contains the top-level object type definitions for an Urakawa multimedia document.

A "Project" can host several "Presentations". Convenient 'open' methods are available to create a "Presentation" instance from a XUK XML file. Alternatively, a whole multimedia document can of course be created from scratch (programmatically).

Each "Presentation" hosts factories for the various object types involved in the data model, as well as providers and managers (see corresponding sections below for more information). The "Presentation" is also the owner of the document tree, made of "TreeNodes" (see the "Core" chapter below).

Please note that the "PropertyFactory" defined at this level of the hierarchy is a wrapper for all the possible property types of the SDK (see the "Property" chapter below).

## Core

"_org.daisy.urakawa.core_": this part of the data model encapsulates the core constructs for the document tree.

A tree made of "TreeNodes" is basically totally generic, it defines a 'blank' hierarchical tree structure. Each node of the tree can host several "Property" objects, which determine the actual content of the tree (see the "Property" chapter below).

### Navigation

The core tree is navigable using the "visitor pattern", a well-known method for accessing and processing nodes of a tree structure (see  "_core.visitor_").

### Events

The core tree includes an event mechanism, for when the document instance is modified. The registration and notification processes are based on the subscribe-publish design pattern. Actually, both the Listener and Observer pattern are available in the data model. SDK implementations may choose one or the other, depending on language-specific optimizations (e.g. C# has built-in support for events).  (see  "_core.event_").

## Commands, Undo-Redo

(See the "_org.daisy.urakawa.undo_" SDK namespace)

Support for Undo-Redo is built in the SDK. It is based on a common pattern called the "Command Pattern".

### Commands

A Command is simply a container for an action, that can be executed once it has been defined (see the execute() method). 

For the purpose of Undo-Redo, a Command can not only be executed, but also undone (see the unExecute() method).

Although Commands are the fundamental underlying mechanism to implement undoable operations, they can be used to encapsulate user actions that are not at all reversible. The canUnExecute() method is used to check wether a Command is reversible.

The getLongDescription() and getLongDescription() methods provide human-friendly descriptions of what the command does. This information is typically used to present the application logic in the user interface. Please note that the provided text must describe the business logic of the execute() method, not of the reversible counterpart unExecute(). See the following paragraph for more information.

### Undo-Redo

Commands provide the low-level construct to encapsulate a reversible action. In order to maintain the integrity of the data model when performing write operations, the UndoRedoManager registers done and undone Commands in the undo stack and the redo stack, respectively (see the execute() method).

The undo() and redo() methods can be called to navigate through the history of changes, and their canUndo() and canRedo() peer methods should be used to check wether there is any Command to undo or redo in the current history stacks.

The flushCommands() can be used to clear all done and undone Commands from the stacks. This effectively resets the history and makes it impossible to undo previous changes !

The getRedoShortDescription() and getUndoShortDescription() methods provide access to the description for the next undoable or redoable Command available, if any. This can typically be used to render the undo-redo history in the user interface, and let the user select the level to undo or redo.

### Composite Commands

Sometimes, a complex operation on the data model needs to be materialized using several Commands that execute in sequence. However, from the user perspective, such complex operation should be undoable in one go (not for each individual Command).

This is the role of a CompositeCommand. It is actually a sub-type of Command that is used to register a sequence of individual Commands (which can be CompositeCommands, recursively. Therefore, nested CompositeCommands are allowed by this mechanism).

Now, instead of manually creating a CompositeCommand object, there is a "Transaction" mechanism built in the UndoRedoManager.

By using startTransaction() to notify the beginning of a lengthy operation, the UndoRedoManager executes any following Commands normally, but waits for a matching call to endTransaction() in order to encapsulate all the registered Commands in a CompositeCommand.

Because CompositeCommands can be nested, Transactions can also be nested, as long as the startTransation() and endTransaction() methods are called in matching pairs.

If the need arise, a Transaction can be terminated prematurely using the cancelTransaction() method. The UndoRedoManager then rolls-back all the affected Commands since the call to startTransaction().

The isTransactionActive() method indicates whether a Transaction is currently active.

### Data Model Persistence, XUK Serialization

The history stack maintained by the UndoRedoManager can be serialized into the XUK XML format. The Commands contained in both the Undo and the Redo stack become persistent, which allows for closing and re-opening a full project while keeping the edition session intact.

### Custom Commands, Extensibility

Command is actually a abstract interface, which has a concrete implementation called CompositeCommand. The SDK also provides built-in Commands for most operations on the Data Model.

However, because the Data Model is itself extensible, it is necessary to allow application developers to create their own Commands with the business logic that they require.

For example, let's say that an application defines the StringTreeNode class which is an extension of TreeNode, with the added ability to store a descriptive character string (e.g. set/getNodeDescription()). In order for changes to this NodeDescription attribute to be registered in the UndoRedoManager (and therefore to be undoable), a new Command is needed (e.g. TreeNodeDescriptionChangeCommand).

## Exceptions

"_org.daisy.urakawa.exception_": this is where common exceptions are defined. Exception types specifically related to some parts of the data model are located in their corresponding package.

## Metadata

"_org.daisy.urakawa.metadata_": a simple model for describing project metadata, designed to be compatible with Daisy metadata and inspired by the [Dublin Core][wwwDublinCore] model.

## Navigator

"_org.daisy.urakawa.navigator_": in large multimedia presentations (like Daisy books), browsing the tree using the conventional tree parsing methods quickly becomes overkill, with lots of boiler-plate code. The "navigator" design builds an abstraction of the full document tree, based on specific selection (filtering) criteria. The resulting "virtual" tree is much smaller and easier to navigate.

## XUK

"_org.daisy.urakawa.xuk_": (de-)serialization in XUK XML format, which allows for storing the data model in a persistent form.

## Properties

"_org.daisy.urakawa.property_": this actual content of the tree structure. While this is an extensible mechanism, the SDK currently has 2 built-in types of properties:

### XML

"_org.daisy.urakawa.property.xml_": this allows for storing XML information in the tree. This is typically used to represent DTBook content from Daisy books (similar to XHTML).

### Channel

"_org.daisy.urakawa.property.channel_": the notion of channel encapsulates the concept of semantically-related multimedia content. For example, within a multimedia presentation, there is an audio stream in English which can be switched dynamically to French. These 2 audio channels are stored separately by the data model, and can be synchronized, extracted, manipulated independently.

During the authoring process, synchronization can be performed adequately. During the generation of content in specific distribution formats (e.g. SMIL or Daisy), the notion of channel is lost in favor of a "cooked" or "flat" structure (easier to interpret by playback applications, and more streamable). The concept of channel is therefore a semantic construct which essentially helps encapsulating content to serve the authoring process.

Channels need to be managed in the sense that a presentation must know about its existing channel containers. This is the role of "ChannelManager".

## Media

"_org.daisy.urakawa.media_": this part materializes the concept of media objects (audio, video, text, etc.), in a rather abstract form that hides the underlying storage and encoding capabilities. By contrast, the "data" sub-package enters the realm of concrete physical implementation.

### Media Data

"_org.daisy.urakawa.media.data_": refers to a physical representation of the media object (file/stream). Because of the inherent memory implications, such data needs to be managed, thus the corresponding "MediaDataManager".

The "codec" sub-package defines codec-specific processing (e.g. MP3).

### Timing

"_org.daisy.urakawa.media.timing_": like the name suggests, this part contains the timing-related modules. As the model evolves, this will probably also include synchronization based on user-interaction.

## Examples

"_org.daisy.urakawa.examples_": this package the data model contains actual implementations that can be compiled and run. This is mainly for demonstration purposes and is not part of the final reference implementations of the SDK.

# Glossary of Terms

<p>For your reference, here is a list of useful acronyms used in this document, in alphabetical order:</p>

<ul>
<ul class="noindent">
	<li><strong><acronym title="Application Programming Interface">API</acronym></strong> (Application Programming Interface)</li>

	<li><strong><acronym title="Digital Talking Books">DTB</acronym></strong> (Digital Talking Books)</li>

	<li><strong><acronym title="Digital Accessible Information SYstem">Daisy</acronym></strong> (Digital Accessible Information SYstem)</li>

	<li><strong><acronym title="Frequently Asked Questions">FAQ</acronym></strong> (Frequently Asked Questions)</li>

	<li><strong><acronym title="National Information Standards Organization">NISO</acronym></strong> (National Information Standards Organization)</li>

	<li><strong><acronym title="Software Development Kit">SDK</acronym></strong> (Software Development Kit)</li>

	<li><strong><acronym title="Synchronized Multimedia Integration Language">SMIL</acronym></strong> (Synchronized Multimedia Integration Language)</li>

	<li><strong><acronym title="Table of Contents">TOC</acronym></strong> (Table of Contents)</li>

	<li><strong><acronym title="Unified Modeling Language">UML</acronym></strong> (Unified Modeling Language)</li>

	<li><strong><acronym title="eXtended Markup Language">XML</acronym></strong> (eXtended Markup Language)</li>

	<li><strong><acronym title="XML for UraKawa">XUK</acronym></strong> (XML for UraKawa)</li>
	<li><strong><acronym title="Object-Oriented Programming">OOP</acronym></strong> (Object-Oriented Programming)</li>
</ul>


</ul>

</div>

-------------------

<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml11" alt="Valid XHTML 1.1" style="border:0;width:88px;height:31px;"/></a><a href="http://jigsaw.w3.org/css-validator/check/referer"><img style="border:0;width:88px;height:31px;" src="http://jigsaw.w3.org/css-validator/images/vcss" alt="Valid CSS"/></a></p>

<div style="height: 600px;">&nbsp;</div>

</body></html>
