
<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11-flat.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US"><head><style type="text/css">body {background-color: #ffffff; color:#333333;font-size:12px;font-family: "Lucida Grande", "Lucida Sans Unicode", verdana, lucida, arial, sans-serif;}.inlinenotes {background-color: #FFF280; padding: 2px;}.red {color: #ff0000;}.green {color: green;}</style><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Urakawa Project - Software Development Kit - Programmer's Guide / Developer Primer</title></head><body>


[emailDanielWECK]: mailto:daniel.weck@gmail.com "Daniel WECK email"

[wwwANT]: http://ant.apache.org/ "www"

[wwwGraphviz]: http://www.graphviz.org/

[wwwUMLGraph]: http://www.spinellis.gr/sw/umlgraph/ "www"

[wwwNetbeans]: http://www.netbeans.org/ "www"
[wwwEclipse]: http://www.eclipse.org/ "www"

[wwwIntelliJ]: http://www.jetbrains.com/ "www"

[wwwW3C-SMIL]: http://www.w3.org/AudioVideo/ "Synchronized Multimedia Integration Language - W3C homepage"
[wwwSMILRec]: http://www.w3.org/TR/SMIL2/ "SMIL W3C Recommendation"

[wwwUrakawaSDKAPIDoc]: http://urakawa.sourceforge.net/sdk/apidoc/ "www"
[wwwUrakawaSDKCSharpDoc]: http://urakawa.sourceforge.net/sdk/APIdoc.zip "www"
[wwwUrakawaUMLDiagrams]: http://urakawa.sourceforge.net/sdk/uml-diagrams/ "www"

[wwwUrakawaDaisyHome]: http://www.daisy.org/projects/urakawa/ "www"

[wwwUrakawaSFHome]: http://urakawa.sourceforge.net/ "www"
[wwwUrakawaObiHome]: http://urakawa.sourceforge.net/obi/ "www"
[wwwUrakawaMirrorDaisyForAll]: http://www.daisy-for-all.org/urakawa-sfmirror/ "www"
[wwwUrakawaMirrorDaisy]: http://www.daisy.org/projects/urakawa/sfmirror/home.html "www"

[wwwUrakawaSFProject]: http://sourceforge.net/projects/urakawa "www"

[wwwUrakawaSVNBrowse]: http://svn.sourceforge.net/viewvc/urakawa/ "www"
[wwwUrakawaSVNBrowseTrunkRoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/ "www"
[wwwUrakawaSVNBrowseArchUMLRoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/architecture/ "www"
[wwwUrakawaSVNBrowseArchJavaRoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/architecture/UMLGraph/src/org/daisy/urakawa/ "www"

[wwwUrakawaSVNBrowseArchIDEARoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/architecture/UMLGraph/ "www"

[wwwUrakawaSVNGuide]: http://sourceforge.net/svn/?group_id=149942 "www"

[wwwLGPL]: http://www.gnu.org/licenses/lgpl.html "www"

[wwwDublinCore]: http://dublincore.org/ "www"

-------------------

# The Urakawa Project
## Application Programming Interface / Software Development Kit
### Programmer's Guide / Developer Primer

_Author/Editor_ : [__Daniel WECK__][emailDanielWECK]  
_Last revision_ : __2007-05-21__

-------------------

# Table of Contents

1. [Introduction][]
  1. [Goal][]
  - [Background][]
  - [UML diagrams ?][]
- [Key Concepts][]
 1. [Data Model Genericity][]
 - [Object Model: Robust and Flexible][]
 - [Persistence with XUK][]
 - [Object Construction using Factories][]
 - [Condition Checking and Exceptions][]
- [Model Structure][]
 1. [Core][]
  1. [Events][]
 - [Commands][]
 - [Exceptions][]
 - [Metadata][]
 - [Navigator][]
 - [XUK][]
 - [Validation][]
 - [Properties][]
 - [Media][]
  1. [Timing][]
  - [Utilities][]
 - [Examples][]

-------------------

# Introduction

## Goal

The purpose of this manual is to provide guidance for software programmers, in order to develop applications based on the Urakawa SDK. Here you can find an overview of the Urakawa data model, a presentation of the API architecture, and detailed information about how to structure application code around the Urakawa library.

Although the API is language-independent by design, the hands-on approach presented here should allow to kick-start a development project in any given programming language.

Ultimately, the "[API-doc][wwwUrakawaSDKAPIDoc]" is the recommended programmer's reference, along with the provided [UML class-diagrams][wwwUrakawaUMLDiagrams] which offer reading convenience (Unified Modeling Language). Additional implementation-specific documentation (e.g. [C# SDK doc][wwwUrakawaSDKCSharpDoc]) is available as well.

## Background

The [Urakawa project][wwwUrakawaSFHome] (mirror available [here][wwwUrakawaMirrorDaisyForAll]) specifies an object-oriented __API__ (Application Programming Interface) and provides a reference implementation written in C# (__SDK__, Software Development Toolkit). The C++ implementation is planned, but the detailed roadmap is not yet available.

__[Obi][wwwUrakawaObiHome]__ is a Daisy authoring tool (audio NCX-only books) which relies on the functionality provided by the SDK. __Tobi__, a new software project that will become public soon, will also be based on the Urakawa SDK. It will handle text as well as audio books, and will showcase the strengths of the Urakawa project.

All of the Urakawa project deliverables are published under an [open-source license][wwwLGPL], so developers are strongly encouraged to checkout the project source code using Sourceforge's [SVN project repository][wwwUrakawaSVNGuide]. Immediate online viewing is also available through the [SVN browser][wwwUrakawaSVNBrowse] (Subversion source code version control repository).

## UML diagrams ?

The Urakawa project is divided into 3 main activities, which are conveniently named:

- "Architecture" (the API design)
- "Implementation" (the SDK reference-implementation)
- "Application" (Obi the show-case application, and later Tobi)

The source code and documents associated with these 3 modules are available in the SVN repository, in [distinct locations][wwwUrakawaSVNBrowseTrunkRoot] identified by their names.

For the purpose of this developer guide, we will focus on the Architecture part of the project, of which the main deliverable is a set of UML class diagrams and a thorough API documentation.

- UML diagrams are available in [PNG format][wwwUrakawaSVNBrowseArchUMLRoot], designed to be viewed on the screen or printed-out on paper.
- Developers probably prefer to work with source files rather than static images, so we recommend the [source code "stub"][wwwUrakawaSVNBrowseArchJavaRoot]. This Java source code is the format used to model the UML diagrams in the first place, but includes extra comments that are not shown in the produced PNG images. It is an accessible format (blind users can read the UML specification that way), which integrates well with your favorite Java IDE (Integrated Development Environment), therefore facilitating navigation. Using a text-based format for UML modeling allows versioning using the traditional SVN / CVS repository system. As a result, the design change history can be viewed using standard "diff" tools.

_Notes about UML diagrams production_:

The production workflow that generates the UML diagrams (PNG images) involves a parser for the Java sources, called [UMLGraph][wwwUMLGraph]. This produces "dot" text files which are then interpreted by [Graphviz][wwwGraphviz] to output a variety of formats (PNG, PDF, etc.). Special UMLGraph annotations are used in addition to the standard JavaDoc comments, in order to supply detailed UML entity information.

If you're curious, the full process is declared using the [ANT][wwwANT] makefile format, stored in the ["build.xml" file][wwwUrakawaSVNBrowseArchIDEARoot].

-------------------

# Key Concepts

## Data Model Genericity

Initially, the Urakawa project aims in priority at Digital Talking Books (e.g. Daisy), but the proposed SDK meets the requirements of many other use-cases, such as accessible motion pictures, general SMIL authoring, etc.

The data model structures a multimedia presentation in a modular and extensible way, to target a variety of application domains. The API is not designed around a specific authoring scenario, but it provides a generic framework for manipulating multimedia documents.

All Urakawa multimedia presentations share the concept of a structured document, based on a central tree which supports enhanced navigation, timing, metadata, media objects, and any application-defined annotations.

## Object Model: Robust and Flexible

The design makes extensive use of interfaces to describe the object-oriented architecture. Interfaces provide services as opposed to instance containers, and they allow greater flexibility in respect to multiple inheritance issues (some popular languages do not support multiple inheritance, others do).

Abstract classes are used only when we explicitly want to limit the application developer's capacity to extend the design (in the object inheritance sense). There are very few abstract classes.

Generally speaking, the only concrete classes that the design includes are named "*Impl", and they are the ones implemented by the toolkit. The "*Impl" classes are usable "out-of-the-box", but application programmers can extend the default implementation by re-using the interfaces definitions which are much more fine-grained than the concrete classes (which are only the result of a combination of interfaces).

Interfaces cannot specify composition or aggregation relationships (in the UML sense), so we have introduced a special UML notation to describe these constructs. This allows the design to encapsulate UML relationships at the lower-level (interfaces) rather than at the class level (which is the result of combining several interfaces together).

This way, we think we achieve the best of both worlds: keeping the flexibility given by interfaces, and being able to specify strong constraints on instance relationships.

For the Urakawa API, defining a programming contract as clear and complete as possible is paramount. This removes ambiguities, clarifies expectations, and ultimately prevents bugs. For example, conditions on the values for method parameters are explicit and require checking, by contract. This is not quite as strict as the ADA development model, but it provide enough safeguards. Also, thorough specification of the aggregation and composition relationships are given to developers, in order to implement the correct memory handling logic. The current C# implementation runs in a managed environment (virtual machine with garbage collection), so the impact is minimal. However, the future C++ implementation will have to explicitly guarantee memory allocation, object ref-counting and freeing of data structures.

## Persistence with XUK

From the outset, the decision was made to have the ability to store a multimedia project in a persistent manner, using a well-defined format. This allows for loss=less round-trip open/save operations.

XUK is a XML serialization format designed for the Urakawa data model, and entities that extend the "Xukable" interface are serializable in this format. XUK is a core feature of the data model, so a reference implementation provides serialization out-of-the-box.

Import and export support for other mainstream multimedia formats like Daisy and SMIL is provided via transformers to/from XUK (this is out of scope, please see the website for more information about that).

## Object Construction using Factories

The Urakawa API makes extensive use of object factories. This is a direct result of using interfaces more than classes, and it provides a good amount of flexibility for creating class instances. For example, a low-resource device will ship special factories implementations with stringent memory management logic (e.g. fly-weight design pattern). So an object type for an interface "ABC" can have several implementations, but the factory hides this to the application developer (e.g. ABCImpl1, ABCImpl2).

Another benefit is that the XML de-serialization process (XUK format) can rely on these factories to re-create a live data structure, based on a simple lookup using qualified names (local-name + namespace). The default factories know how to create instances for a certain number of qualified-names, but application developers can extend with their custom factories, in order to support custom namespaces in the XUK format.

Constructors are therefore only used internally by the reference implementation, following the construct-initialize instantiation pattern. Application developers only use factories to produce instances, and use the generic type instead of the concrete "*Impl" type.

## Condition Checking and Exceptions

The model uses checked exceptions to describe conditions for method parameter values (e.g. boundaries for integers, null pointers, etc.). This is a convenience for defining the implementation contract, but it does not mean that implementations have to use costly checked exceptions (i.e. mandatory try/catch, etc.).

A properly-written reference SDK implementation must follow the contract strictly to provide a guarantee to the application developer. These conditions on method parameter values should take part in unit-testing as well.

Generally in UML, sequence diagrams are used to represent exceptions, as they relate to controlling the execution flow. Here, we use a special UML annotation to decorate our standard class diagrams.

Reference SDK implementations are encouraged to use "real" checked exceptions at least in debug mode, as it is a nice way to trace bugs using the generated stack trace reports.

-------------------

# Model Structure

The UML class diagrams (PNG images) are divided into several groups, mainly for visual clarity. The aim is to provide a printable form of the model, for quick reference.

On the other hand, the Java source code is structured hierarchically, using the standard Java "packages". Each package corresponds to a physical folder, which encapsulates related concepts. The [Java source code][wwwUrakawaSVNBrowseArchJavaRoot] is easy to browse and provides a very good view of the API's object-oriented model. Any decent Java class browser should provide a nice structured tree-view to navigate the data model.

"_org.daisy.urakawa_" is the root package (or "namespace") of the project. It contains the main object definitions which can be directly used to host a multimedia document and author it. These top-level definitions basically combine and/or inherit the functionality of finer-scoped object types defined throughout the model hierarchy.

## Core

"_org.daisy.urakawa.core_": this part of the data model encapsulates the essential feature set of the toolkit. This means that this is the minimum amount of functionality an application developer is expected to use.

In this limited world, a multimedia presentation (see "CorePresentation*") is made of a generic tree (see "CoreNode*") which supports annotations (see "_core.property_"). It is the "property" part of the data model which really gives the tree some semantics (multimedia features), and therefore it is essential. Later in this guide, the default "properties" provided by the toolkit will be explained.

Additionally, the core tree is by default navigable using the "visitor pattern", a well-known method for accessing and processing nodes of a tree structure (see  "_core.visitor_").

### Events

"_org.daisy.urakawa.core.event_": this part of the design is an application of the Event Listener Pattern, which provides application developers with a framework for handling change-events that occur in the main presentation tree. In the context of MVC (Model-View-Controler) user-interfaces, the ability to capture data model changes is paramount.

## Commands

"_org.daisy.urakawa.commands_": currently under review, this part of the data model is used to specify the "command pattern" for operations on the multimedia tree. This allows for an easily extensible undo-redo framework.

## Exceptions

"_org.daisy.urakawa.exceptions_": this is where ALL of the model exceptions are defined, regardless of where they are actually used.

## Metadata

"_org.daisy.urakawa.metadata_": a simple model for describing project metadata, designed to be compatible with Daisy metadata and inspired by the [Dublin Core][wwwDublinCore] model.

## Navigator

"_org.daisy.urakawa.navigator_": in large multimedia presentations (like Daisy books), browsing the tree using the conventional tree parsing methods quickly becomes overkill, with lots of boiler-plate code. The "navigator" design allows for abstracting the inherent tree complexity based on specific selection criteria, which filter the real tree and produces and "virtual" tree, much smaller and easier to navigate.

## XUK

"_org.daisy.urakawa.xuk_": the essential (de-)serialization in XUK XML format, which allows for storing the data model in a persistent form. The local-name + namespace association ("fully-qualified name") is an key design choice to identify parts of the format. It allows factories to match names with actual object types in the data model, which makes (de-)serialization possible.

## Validation

"_org.daisy.urakawa.validation_": currently under review, this module aims at providing a framework for validating content as it is authored. The objective is mainly preemptive validation, that is to say before the actual operation is performed (e.g. this can be used for ensuring GUI affordance).

## Properties

"_org.daisy.urakawa.properties_": this is the part of the design that gives the tree actual content to work with. It defines the types of annotations that are provided in the default toolkit implementation, baring in mind that this is an extensible mechanism. Currently there are 2 types of properties:

### XML

"_org.daisy.urakawa.properties.xml_": this allows for storing XML information in the tree. This is typically used to represent DTBook content from Daisy books.

### Channel

"_org.daisy.urakawa.properties.channel_": the notion of channel encapsulates the concept of semantically-related multimedia content. For example, within a multimedia presentation, there is an audio stream in English which can be switched dynamically to French. These 2 audio channels are stored separately by the data model, and can be synchronized, extracted, manipulated independently.

During the authoring process, synchronization can be performed adequately. During the generation of content in specific distribution formats (e.g. SMIL or Daisy), the notion of channel is lost in favor of a "cooked" or "flat" structure (easier to interpret by playback applications, and more streamable). The concept of channel is therefore a semantic construct which essentially helps encapsulating content to serve the authoring process.

Channels need to be managed in the sense that a presentation must know about its existing channel containers. This is the role of "ChannelManager".

## Media

"_org.daisy.urakawa.media_": this part materializes the concept of media objects (audio, video, text, etc.), in a rather abstract form that attempts to hide the underlying storage and encoding capabilities. See for example, the "MediaLocation" entity. In contrast, the "asset" sub-package enters the realm of concrete physical implementation.

### Asset

"_org.daisy.urakawa.media.asset_": the term "asset" refers to a physical representation of the media object (file/stream), that uses specific encodings for storage/distribution purposes. Because of the inherent memory implications, such assets need to be managed, thus the corresponding "MediaAssetManager".

### Timing

"_org.daisy.urakawa.media.timing_": like the name suggests, this part contains the timing-related modules. As the model evolves, this will probably also include synchronization based on user-interaction.

### Utilities

"_org.daisy.urakawa.utilities_": the role of this package is to contain utility functions that support the realization of functionality in other areas of the toolkit, but that are not really part of the data model. For example, audio analysis is categorized as "utility", as the primary goal of the Urakawa toolkit is not to be a full-blown audio/video processing environment.

## Examples

"_org.daisy.urakawa.examples_": this package the data model contains actual implementations that can be compiled and run. This is mainly for demonstration purposes and is not part of the final reference implementations of the toolkit, like the provided C# one.

-------------------

<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml11" alt="Valid XHTML 1.1" style="border:0;width:88px;height:31px;"/></a><a href="http://jigsaw.w3.org/css-validator/check/referer"><img style="border:0;width:88px;height:31px;" src="http://jigsaw.w3.org/css-validator/images/vcss" alt="Valid CSS"/></a></p>

<div style="height: 600px;">&nbsp;</div>

</body></html>


/**
 * Abstract factory pattern: from the API user perspective: do not use
 * constructors, use a factory instead (which will delegate to the real
 * constructor of its choice). - A Factory offers much more flexibility than
 * standard constructors. For example, optimized constructors can be used for
 * instanciating many objects at once (e.g. parallel processing). - Another
 * example is to have a memory-efficient object allocator for when instanciating
 * many objects of the same type throught the course of the execution of the
 * program, by always returning the same "Flyweight" instance of the object
 * (e.g. Text media object is likely to created thousands of times in a Daisy
 * book, for each small fragment of text). Implementation of the "Flyweight"
 * pattern are quite common: Dom4J (Namespace object), Swing (TreeRenderer),
 * etc. More info:
 * http://exciton.cs.rice.edu/javaresources/DesignPatterns/FlyweightPattern.htm -
 * This factory may be implemented as a singleton, but this is not a
 * requirement. The implementation can decide what pattern suits it best. - This
 * factory should take care of building certain types of Nodes, characterized by
 * their Property attribute. For example, Daisy nodes should include a
 * ChannelsProperty with audio and text channel, which imply that the channel
 * must be registered by the ChannelsManager beforeHand. This also has
 * implication on what a Validator does for the type of Node created.
 * 
 * 
 */