<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11-flat.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US"><head><style type="text/css">body {background-color: #ffffff; color:#333333;font-size:12px;font-family: "Lucida Grande", "Lucida Sans Unicode", verdana, lucida, arial, sans-serif;}.inlinenotes {background-color: #FFF280; padding: 2px;}.red {color: #ff0000;}.green {color: green;}</style><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Urakawa Project - Software Development Kit (SDK) - Programmer's Guide / Developer Primer</title></head><body>


[emailDanielWECK]: mailto:daniel.weck@gmail.com "Daniel WECK email"

[wwwDaisyPipeline]: http://www.daisy.org/projects/pipeline/ "www"

[wwwANT]: http://ant.apache.org/ "www"

[wwwGraphviz]: http://www.graphviz.org/

[wwwUMLGraph]: http://www.spinellis.gr/sw/umlgraph/ "www"

[wwwNetbeans]: http://www.netbeans.org/ "www"
[wwwEclipse]: http://www.eclipse.org/ "www"

[wwwIntelliJ]: http://www.jetbrains.com/ "www"

[wwwW3C-SMIL]: http://www.w3.org/AudioVideo/ "Synchronized Multimedia Integration Language - W3C homepage"
[wwwSMILRec]: http://www.w3.org/TR/SMIL2/ "SMIL W3C Recommendation"

[wwwUrakawaSDKAPIDoc]: http://urakawa.sourceforge.net/sdk/apidoc/ "www"
[wwwUrakawaSDKCSharpDoc]: http://urakawa.sourceforge.net/sdk/APIdoc.zip "www"
[wwwUrakawaUMLDiagrams]: http://urakawa.sourceforge.net/sdk/uml-diagrams/ "www"

[wwwUrakawaDaisyHome]: http://www.daisy.org/projects/urakawa/ "www"

[wwwUrakawaSFHome]: http://urakawa.sourceforge.net/ "www"
[wwwUrakawaObiHome]: http://urakawa.sourceforge.net/obi/ "www"
[wwwUrakawaMirrorDaisyForAll]: http://www.daisy-for-all.org/urakawa-sfmirror/ "www"
[wwwUrakawaMirrorDaisy]: http://www.daisy.org/projects/urakawa/sfmirror/home.html "www"

[wwwUrakawaSFProject]: http://sourceforge.net/projects/urakawa "www"

[wwwUrakawaSVNBrowse]: http://svn.sourceforge.net/viewvc/urakawa/ "www"
[wwwUrakawaSVNBrowseTrunkRoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/ "www"
[wwwUrakawaSVNBrowseArchUMLRoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/architecture/ "www"
[wwwUrakawaSVNBrowseArchJavaRoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/architecture/UMLGraph/src/org/daisy/urakawa/ "www"

[wwwUrakawaSVNBrowseArchIDEARoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/architecture/UMLGraph/ "www"

[wwwUrakawaSVNGuide]: http://sourceforge.net/svn/?group_id=149942 "www"

[wwwLGPL]: http://www.gnu.org/licenses/lgpl.html "www"

[wwwDublinCore]: http://dublincore.org/ "www"

-------------------

# The Urakawa Project
## Application Programming Interface / Software Development Kit
### Implementor's Guide / Developer Primer

_Author/Editor_ : [__Daniel WECK__][emailDanielWECK]  
_Last revision_ : __2007 October 05__

-------------------

# Table of Contents

1. [Introduction][]
  1. [Goal][]
  - [Project Organization][]
  - [Java and UML][]
- [Key Concepts][]
 1. [Data Model Genericity][]
 - [Reading the Data Model][]
 - [Persistence with XUK][]
 - [Object Creation using Factories][]
 - [Condition Checking and Exceptions][]
- [Model Structure][]
 1. [Core][]
  1. [Navigation][]
  - [Events][]
 - [Commands, Undo-Redo][]
 - [Exceptions][]
 - [Metadata][]
 - [Navigator][]
 - [XUK][]
 - [Properties][]
  1. [XML][]
  - [Channel][]
 - [Media][]
  1. [Media Data][]
  - [Timing][]
 - [Examples][]
- [Glossary of Terms][]

-------------------

# Introduction

## Goal

The intended audience for this document is:

* designers / architects of the Urakawa SDK's data model and facade API.
* implementors of the Urakawa SDK (e.g. C++, Java, C# toolkit developers).
* application developers of software tools using / based-on the SDK.

The purpose of this manual is to:

* provide a high-level overview of the SDK data model.
* provide a "plain-english" description of the API architecture (complement to the "API-doc").
* provide guidance and tips for software programmers, in a language-neutral way.

Please note that this guide is __not__ a replacement for the "[API-doc][wwwUrakawaSDKAPIDoc]", which remains the recommended programmer's reference. Additional [UML class-diagrams][wwwUrakawaUMLDiagrams] (Unified Modeling Language) offer some reading convenience.

This guide does __not__ provide information for language-specific SDK implementations. Instead, it describes the generic language-agnostic object-oriented model of the SDK. The SDK design may be implemented as-is, modulo any particular language optimizations. For implementation-specific details, please refer to the appropriate documentation (e.g. [C# SDK doc][wwwUrakawaSDKCSharpDoc]).

## Project Organization

The [Urakawa project][wwwUrakawaSFHome] (website mirror available [here][wwwUrakawaMirrorDaisyForAll]) specifies an object-oriented multimedia authoring __data model__, and an __API__ (Application Programming Interface). The project provides a reference implementation written in C# (__SDK__, Software Development Toolkit).

Several applications are developed under the same project umbrella. They rely on the functionality provided by the SDK. __[Obi][wwwUrakawaObiHome]__ is a Daisy authoring tool for audio-only books. __Tobi__ (a new software project that will become public soon) will facilitate the authoring of full-text full-audio DTBs (digital talking books).

All of the Urakawa project deliverables are published under an [open-source license][wwwLGPL]. Developers are strongly encouraged to checkout the project source code using Sourceforge's [SVN project repository][wwwUrakawaSVNGuide] (Subversion source code version control). Instant and up-to-date online browsing is also available via the [SVN viewer][wwwUrakawaSVNBrowse].

To reflect the aforementioned deliverables, the Urakawa project is conveniently divided into 3 main activities:

- "Architecture" => the SDK design (data model and API)
- "Implementation" => the SDK reference-implementation (currently C#)
- "Application" => working applications based on the SDK (currently Obi, soon-to-come Tobi)

The source code and documents associated with these 3 modules are available in the SVN repository, in [distinct locations][wwwUrakawaSVNBrowseTrunkRoot] identified by their names.

In the present document, we will focus on the _Architecture_ part of the project, for which the main deliverables (other than the present document) are essentially a set of UML class diagrams and a thoroughly documented abstract API.

## Java and UML

The SDK's data model and facade API are specified in an Object-Oriented (OO) fashion. A set of UML class diagrams is used to conveniently present modules of the software architecture.

The UML diagrams are [distributed][wwwUrakawaSVNBrowseArchUMLRoot] in the PNG image format, and are designed primarily to be viewed on a computer display, and optionally to be printed-out on paper.

The UML diagrams are not drawn manually: they are generated automatically from a plain-text declarative format. The software architecture is therefore accessible to blind and visually impaired users, using screen-readers with the original source rather than the visual diagrams.

This source material is in fact plain Java code, augmented with special annotations used in the JavaDoc comments for configuring the set of UML diagrams. Developers will probably prefer to read the source code directly (using a regular Java IDE or source editor), rather than looking at static UML images. Please consult the [SVN repository][wwwUrakawaSVNBrowseArchJavaRoot] to browse the code.

Java was chosen as the declarative form of the Object-Oriented architecture and API, but the SDK is not Java-only or Java-centric ! Any language that supports OOP can be used to implement the SDK, and language-specific optimizations are recommended (the Urakawa project's own C# SDK implementation illustrates this pretty well).

Because the SDK architecture is specified in plain-text format, it is entirely maintained under a revision control system, namely SVN ("Subversion"). As a result, the history of changes can be viewed using the standard "diff" tools, and updates can easily be managed collaboratively.

The UML diagrams production process involves a special parser for the Java sources, called [UMLGraph][wwwUMLGraph]. This tool produces "dot" files (plain-text declarative graph format) which are then interpreted by [Graphviz][wwwGraphviz] to output a variety of formats (PNG, PDF, HTML image maps, etc.).

In order to supply detailed UML entity information, special UMLGraph annotations are used in the source Java code (amongst the standard JavaDoc comments). The full generation process is implemented using the [ANT][wwwANT] makefile format, see the ["build.xml" file][wwwUrakawaSVNBrowseArchIDEARoot].

-------------------

# Key Concepts

## Data Model Genericity

Currently, the Urakawa project aims at facilitating the authoring of DTBs (Digital Talking Book), like Daisy.

However, the SDK is designed to be future-proof, by providing an abstraction layer above common multimedia distribution formats. As a result, the Urakawa SDK potentially meets the requirements of many other use-cases, such as accessible motion pictures, general SMIL authoring, etc.

In order to support a variety of application domains, the Urakawa data model is modular and the API is extensible.

Multimedia presentations based on the Urakawa data model are highly-structured documents, based on a __core tree__ which supports enhanced navigation, timing, metadata, media types, etc.

Custom constructs (application-defined) can be added using the extensibility mechanism of Object-Oriented programming (e.g. subclassing), and by configuring object factories.

The core tree is totally abstract so the semantics are given by attaching "properties" to the nodes of the tree.

The SDK provides built-in properties (e.g. to attach audio and text media objects), but this can be extended very easily to meet specific application requirements (e.g. a "todo" property to mark nodes that require the author to edit the content before publishing). 

Generally-speaking, any kind of data can be attached to a node via its properties. In some simple use-cases, subclassing the tree-node class may be preferred, but setting and querying properties via the property mechanism is generally recommended.

Here is a simple, concrete example:

- Let's assume that a given tree node in the presentation document is the structural equivalent of a "h1" HTML header: an XmlProperty defines the structural semantics of the tree node.
- This "h1" element is a navigable access point to be included in the document's table of content, so it is marked as such using a custom property type (e.g. NavigationTargetProperty).
- Attached to the tree-node is an audio file (e.g. MP3) for the human narration in English of the "h1" text label.
- Also attached is an audio narration in Spanish of the same "h1" title. To distinguish this audio content from the previous one, a dedicated "channel" is used (read-on for full details about this construct).

## Reading the Data Model

The SDK object-oriented architecture written in Java makes extensive use of interfaces. Interfaces provide service description (via a set of methods) as opposed to describing instance containers (like classes). They enable more flexibility in respect to multiple inheritance (some languages do not support multiple inheritance, others do). By comparison, W3C DOM is a prime example for the use of interfaces. IDL (Interface Definition Language) is also representative of the benefits of abstraction.

In the Java code, concrete classes are often named "*Impl" (e.g. TreeNodeImpl), and have an equivalent base interface (e.g. TreeNode). This is because the SDK uses the factory design pattern to generate instances, in order to facilitate round-trip serialization into the Urakawa XML format (XUK). For more information about XUK and factories, please refer to the appropriate sections of this document.

Generally-speaking, a base interface can have several concrete implementations for which instances can be generated transparently by the factory methods. Each individual implementation obey the basic contract of the interface, and this is all that matter at the SDK level. Of course, application-programmers can access the additional services provided by their custom classes using explicit casting when necessary.

By default, the SDK provides single implementations but applications can extend this behaviour to meet their requirements (e.g. TreeNodeMobileDeviceImpl vs TreeNodeWebServerImpl, with totally different memory requirements).

Implementations which do not wish to expose multiple realizations of a base interface my choose to exclude the base interface from their design and include the concrete class only. Base interfaces and are marked with the "@leafInterface" annotation, so they are easily identifiable as optional.

There is another type of optional interface in the Urakawa SDK architecture, which is provided only for reading convenience (splitting the design in distinct, smaller modules). Such interfaces are marked with the "@designConvenienceInterface" annotation, and SDK implementors may choose not to include them in their implementation.

Abstract classes are used when we explicitly want to limit the application developer's capacity to extend the design (in the object-oriented single-inheritance sense), and force the developer to extend the class to implement application-level business logic.

Interfaces cannot specify "composition" or "aggregation" relationships (in the UML "association" sense), but the SDK design uses a special UML notation to describe these relationships at the interface level (instead of at the level of the concrete classes). The motivation for this non-UML-standard addition is simply that *Impl concrete classes are usually not easy to read, because of the number of methods they contain. By placing the association links at the level of the base interfaces, the Urakawa software design is a lot easier to understand and navigate. The resulting UML diagrams also benefit from the improved readability.

The Urakawa SDK (data model and API) advocates "programming by contract". This facilitates unit-testing, removes ambiguities and clarifies expectations amongst developer teams. To achieve this:

- the design includes strict checking of the values of method parameters. The assert conditions are described using checked exceptions for reading convenience, but of course implementations do not actually have to use exceptions at all (see the related chapter in this manual). The objective is to promote fail-fast behaviour as much as possible.
- UML associations such as aggregation and composition are extremely useful. They are an integral part of the design contract, as they describe ownership rules between object instances. This is useful information for implementations in languages that require manual memory handling, as opposed to managed-languages (e.g. Java and C#) which execute within the context of a virtual-machine and automatically handle garbage collection. (a C++ reference implementation would need to explicitly manage memory allocation and object ref-counting, to guarantee object integrity and prevent memory leaks).

## Persistence with XUK

The Urakawa SDK is based on a data model with native support for serialization in an XML format, called XUK. This provides authoring applications with a built-in mechanism ("out-of-the-box") for document persistence and allows for loss-less round-trip open/save operations.

XUK is an XML format for which the schema (grammar) is dependent on the application that uses the SDK (applications are likely to extend the default document model provided by the SDK). XML namespaces are used to distinguish between the default SDK serializable objects, and the custom application-specific types.

The "Xukable" interface is implemented by any object type that is serializable into the XUK format.

Support for importing and exporting other mainstream multimedia formats (e.g. Daisy, SMIL) is possible by converting to and from the XUK format. This is however out of scope for the SDK itself, so this functionality must be provided by third-party modules. The [Daisy Pipeline][wwwDaisyPipeline] provides transformers for many multimedia document types, and there are plans to develop support for the XUK format.

## Object Creation using Factories

The Urakawa API makes extensive use of factories for generating object instances (Factory Design Pattern).

This design choice stems from the requirements of round-trip serialization into the Urakawa XML format (XUK). A factory is able to generate an object instance based on a given type, specified by a fully qualified name (in the XML sense). As such, there is a direct mapping between element names in a XUK instance and object types in the data model.

Generally-speaking, a base interface can have several concrete implementations for which instances can be generated transparently by the factory methods. For example:
* TreeNode => base interface
* TreeNodeImpl => concrete implementation
* TreeNode TreeNodeFactory.createTreeNode(QName) => factory method

By default, the SDK provides single implementations but applications can extend this behaviour to meet their requirements (e.g. TreeNodeMobileDeviceImpl vs TreeNodeWebServerImpl).The default factories provided by the SDK can also be extended to support application-specific types.

As a result of this, not much emphasis is put on constructors in the SDK design. Instead, a fully constructed object is the result of its creation (using the factory) and of its initialization (by setting some required attributes). However, actual implementations may choose to expose constructors that take as many parameters as necessary to realize both creation and initialization at the same time (factory methods may also include more initialization parameters than specified in the design).

In fact, the whole initialization phase is a design-specific approach which is materialized my explicit setters (with matching getters). These methods tend to clutter the design, so for reading convenience they are usually extracted in a separate interface named "With*" (e.g. WithQualifiedName). Languages like C# provide native support for class attributes get and set methods, so implementors may choose not to expose explicit getters and setters. If so, special care should be taken to assert the conditions expressed in the SDK design (e.g. setName(String) "cannot pass a null or empty string value"). Note: setter methods that play a role in initializing object instances are marked with the "@stereotype Initialize" annotation. This stereotype actually appears in the resulting UML class diagrams as well.

## Condition Checking and Exceptions

Generally-speaking, exceptions should never be used for controlling the execution flow. The exceptions used in the Urakawa SDK design describe conditions for method input parameter values (e.g. boundaries for integers, null pointers, empty string values, etc.).

This is convenient for defining the implementation contract, but it does not mean that implementations have to use actual checked exceptions (they tend to have a negative impact on performance and require explicit try/catch/finally control structures). Instead, implementations may decide to use unchecked exceptions (ideal, as they generate full stack-trace reports), HRESULT values (very portable), or may choose not to return an error at all. The later is however not recommended, as asserting method parameter values can eliminate a great number of bugs, which are often difficult to trace if no adequate safeguard is implemented.

The UML class diagrams include a special annotation to visually represent the assertions on method parameter values.

-------------------

# Model Structure

The UML class diagrams (PNG images) are divided into several modules, which are carefully designed to enhance the reading experience. The goal is to present views of the architecture at various levels, and to remove unnecessary entities from diagrams that focus on particular characteristics of the data model.

The source material for the UML diagrams is the [Java source code][wwwUrakawaSVNBrowseArchJavaRoot]. This expression of the OO design contract is structured hierarchically, using standard Java "packages". As such, each package corresponds to a physical folder.

As a result, the SDK data model and facade API is easy to browse, using the user's preferred method (full-fledge Java IDE, command-line, text-editor, etc.). There are very good Java IDEs out there (e.g. Eclipse, Netbeans, IntelliJ IDEA, etc.), which provides quick keyboard navigation via their structured views. Blind and visually-impaired developers should be able to comfortably work with the SDK.

## Top-level

"_org.daisy.urakawa_" is the root package (or "namespace") of the project. It contains the top-level object type definitions for an Urakawa multimedia document.

A "Project" can host several "Presentations". Convenient 'open' methods are available to create a "Presentation" instance from a XUK XML file. Alternatively, a whole multimedia document can of course be created from scratch (programmatically).

Each "Presentation" hosts factories for the various object types involved in the data model, as well as providers and managers (see corresponding sections below for more information). The "Presentation" is also the owner of the document tree, made of "TreeNodes" (see the "Core" chapter below).

Please note that the "PropertyFactory" defined at this level of the hierarchy is a wrapper for all the possible property types of the SDK (see the "Property" chapter below).

## Core

"_org.daisy.urakawa.core_": this part of the data model encapsulates the core constructs for the document tree.

A tree made of "TreeNodes" is basically totally generic, it defines a 'blank' hierarchical tree structure. Each node of the tree can host several "Property" objects, which determine the actual content of the tree (see the "Property" chapter below).

### Navigation

The core tree is navigable using the "visitor pattern", a well-known method for accessing and processing nodes of a tree structure (see  "_core.visitor_").

### Events

The core tree includes an event mechanism, for when the document instance is modified. The registration and notification processes are based on the subscribe-publish design pattern. Actually, both the Listener and Observer pattern are available in the data model. SDK implementations may choose one or the other, depending on language-specific optimizations (e.g. C# has built-in support for events).  (see  "_core.event_").

## Commands, Undo-Redo

(See the "_org.daisy.urakawa.undo_" SDK namespace)

Support for Undo-Redo is built in the SDK. It is based on a common design practice called the "Command Pattern".

### Commands

A Command is simply a container for an action, that can be executed once it has been defined (see the execute() method). 

For the purpose of Undo-Redo, a Command can not only be executed, but also undone (see the unExecute() method).

Although Commands are the fundamental underlying mechanism to implement undoable operations, they can be used to encapsulate user actions that are not at all reversible. The canUnExecute() method is used to check wether a Command is reversible.

The getLongDescription() and getLongDescription() methods provide human-friendly descriptions of what the command does. This information is typically used to present the application logic in the user interface. Please note that the provided text must describe the business logic of the execute() method, not of the reversible counterpart unExecute(). See the following paragraph for more information.

### Undo-Redo

Commands provide the low-level construct to encapsulate a reversible action. In order to maintain the integrity of the data model when performing write operations, the UndoRedoManager registers done and undone Commands in the undo stack and the redo stack, respectively (see the execute() method).

When a non-reversible Command is executed via the UndoRedoManager, the undo and redo stacks get invalidated (flushed), so further calls to undo() and redo() will be unsuccessful. However when a reversible Command is registered via the execute() method, it is pushed onto the undo stack and the redo stack gets flushed.

The undo() and redo() methods can be called to navigate through the history of changes, and their canUndo() and canRedo() peer methods should be used to check wether there is any Command to undo or redo in the current history stacks.

The flushCommands() can be used to clear all done and undone Commands from the stacks. This effectively resets the history and makes it impossible to undo previous changes !

The getRedoShortDescription() and getUndoShortDescription() methods provide access to the description for the next undoable or redoable Command available, if any. This typically delegates to the Command's own getShortDescription() method, so textual descriptions should be judiciously chosen so that a simple prepend of "Undo:" and "Redo:" is self-explicit and non-ambiguous (e.g. "Add a node to the tree.", "Redo: Add a node to the tree.", "Undo: Add a node to the tree.").

This can typically be used to render the undo-redo history in the user interface, and let the user select the level to undo or redo. To achieve this, the getListOfRedoStackCommands() and getListOfUndoStackCommands() methods can be used.

### Composite Commands

Sometimes, a complex operation on the data model needs to be materialized using several Commands that execute in sequence. However, from the user perspective, such complex operation should be undoable in one go (not for each individual Command).

This is the role of a CompositeCommand. It is actually a sub-type of Command that is used to register a sequence of individual Commands (which can be CompositeCommands, recursively. Therefore, nested CompositeCommands are allowed by this mechanism).

The getShortDescription() and getLongDescription() methods can be set to return a custom human-friendly label, or by default a description will be generated by concatenating each individual Command's description (recursively). It is therefore recommended to use setShortDescription() and setLongDescription() in order to keep the text readable.

Now, instead of manually creating a CompositeCommand object, there is a "Transaction" mechanism built in the UndoRedoManager.

By using startTransaction() to notify the beginning of a lengthy operation, the UndoRedoManager executes any following Commands normally, but waits for a matching call to endTransaction() in order to encapsulate all the registered Commands in a CompositeCommand.

Because CompositeCommands can be nested, Transactions can also be nested, as long as the startTransation() and endTransaction() methods are called in matching pairs.

If the need arise, a Transaction can be terminated prematurely using the cancelTransaction() method. The UndoRedoManager then rolls-back all the affected Commands since the call to startTransaction().

The isTransactionActive() method indicates whether a Transaction is currently active. There are a number of operations that cannot be done while a Transaction is active, such as trying to undo() or redo(). Once Transactions (potentially nested) are completed normally (the last call to endTransaction() matches the first call to startTransaction()), then the system is back to normal and a call to undo() will reverse the finished Transaction. Obviously, cancelTransaction() can also be used to terminate the current operation, rollback the committed Commands, and return to normal.

The getListOfCommandsInCurrentTransactions() method lists Commands that are NOT in the undo stack, because a Transaction places Commands in a temporary state until they are finally committed to the undo stack by using endTransaction().

### Data Model Persistence, XUK Serialization

The history stack maintained by the UndoRedoManager can be serialized into the XUK XML format. The Commands contained in both the Undo and the Redo stack become persistent, which allows for closing and re-opening a full project while keeping the edition session intact.

### Custom Commands, Extensibility

In the SDK, Command is actually an abstract interface, which has a concrete implementation called CompositeCommand.

However, because the Data Model is itself extensible, it is necessary to allow application developers to create their own Commands with the business logic that they require.

For example, let's say that an application defines the StringTreeNode class which is an extension of TreeNode, with the added ability to store a descriptive character string (e.g. set/getNodeDescription()). In order for changes to this NodeDescription attribute to be registered in the UndoRedoManager (and therefore to be undoable), a new Command is needed (e.g. TreeNodeDescriptionChangeCommand).

The application developers therefore have the responsibility of writing concrete Command classes that meet the requirements of their application's business logic.

## Exceptions

"_org.daisy.urakawa.exception_": this is where common exceptions are defined. Exception types specifically related to some parts of the data model are located in their corresponding package.

## Metadata

"_org.daisy.urakawa.metadata_": a simple model for describing project metadata, designed to be compatible with Daisy metadata and inspired by the [Dublin Core][wwwDublinCore] model.

## Navigator

"_org.daisy.urakawa.navigator_": in large multimedia presentations (like Daisy books), browsing the tree using the conventional tree parsing methods quickly becomes overkill, with lots of boiler-plate code. The "navigator" design builds an abstraction of the full document tree, based on specific selection (filtering) criteria. The resulting "virtual" tree is much smaller and easier to navigate.

## XUK

"_org.daisy.urakawa.xuk_": (de-)serialization in XUK XML format, which allows for storing the data model in a persistent form.

## Properties

"_org.daisy.urakawa.property_": this actual content of the tree structure. While this is an extensible mechanism, the SDK currently has 2 built-in types of properties:

### XML

"_org.daisy.urakawa.property.xml_": this allows for storing XML information in the tree. This is typically used to represent DTBook content from Daisy books (similar to XHTML).

### Channel

"_org.daisy.urakawa.property.channel_": the notion of channel encapsulates the concept of semantically-related multimedia content. For example, within a multimedia presentation, there is an audio stream in English which can be switched dynamically to French. These 2 audio channels are stored separately by the data model, and can be synchronized, extracted, manipulated independently.

During the authoring process, synchronization can be performed adequately. During the generation of content in specific distribution formats (e.g. SMIL or Daisy), the notion of channel is lost in favor of a "cooked" or "flat" structure (easier to interpret by playback applications, and more streamable). The concept of channel is therefore a semantic construct which essentially helps encapsulating content to serve the authoring process.

Channels need to be managed in the sense that a presentation must know about its existing channel containers. This is the role of "ChannelManager".

## Media

"_org.daisy.urakawa.media_": this part materializes the concept of media objects (audio, video, text, etc.), in a rather abstract form that hides the underlying storage and encoding capabilities. By contrast, the "data" sub-package enters the realm of concrete physical implementation.

### Media Data

"_org.daisy.urakawa.media.data_": refers to a physical representation of the media object (file/stream). Because of the inherent memory implications, such data needs to be managed, thus the corresponding "MediaDataManager".

The "codec" sub-package defines codec-specific processing (e.g. MP3).

### Timing

"_org.daisy.urakawa.media.timing_": like the name suggests, this part contains the timing-related modules. As the model evolves, this will probably also include synchronization based on user-interaction.

## Examples

"_org.daisy.urakawa.examples_": this package the data model contains actual implementations that can be compiled and run. This is mainly for demonstration purposes and is not part of the final reference implementations of the SDK.

# Glossary of Terms

<p>For your reference, here is a list of useful acronyms used in this document, in alphabetical order:</p>

<ul>
<ul class="noindent">
	<li><strong><acronym title="Application Programming Interface">API</acronym></strong> (Application Programming Interface)</li>

	<li><strong><acronym title="Digital Talking Books">DTB</acronym></strong> (Digital Talking Books)</li>

	<li><strong><acronym title="Digital Accessible Information SYstem">Daisy</acronym></strong> (Digital Accessible Information SYstem)</li>

	<li><strong><acronym title="Frequently Asked Questions">FAQ</acronym></strong> (Frequently Asked Questions)</li>

	<li><strong><acronym title="National Information Standards Organization">NISO</acronym></strong> (National Information Standards Organization)</li>

	<li><strong><acronym title="Software Development Kit">SDK</acronym></strong> (Software Development Kit)</li>

	<li><strong><acronym title="Synchronized Multimedia Integration Language">SMIL</acronym></strong> (Synchronized Multimedia Integration Language)</li>

	<li><strong><acronym title="Table of Contents">TOC</acronym></strong> (Table of Contents)</li>

	<li><strong><acronym title="Unified Modeling Language">UML</acronym></strong> (Unified Modeling Language)</li>

	<li><strong><acronym title="eXtended Markup Language">XML</acronym></strong> (eXtended Markup Language)</li>

	<li><strong><acronym title="XML for UraKawa">XUK</acronym></strong> (XML for UraKawa)</li>
	<li><strong><acronym title="Object-Oriented Programming">OOP</acronym></strong> (Object-Oriented Programming)</li>
</ul>


</ul>

</div>

-------------------

<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml11" alt="Valid XHTML 1.1" style="border:0;width:88px;height:31px;"/></a><a href="http://jigsaw.w3.org/css-validator/check/referer"><img style="border:0;width:88px;height:31px;" src="http://jigsaw.w3.org/css-validator/images/vcss" alt="Valid CSS"/></a></p>

<div style="height: 600px;">&nbsp;</div>

</body></html>
