<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11-flat.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US"><head><style type="text/css">body {background-color: #ffffff; color:#333333;font-size:12px;font-family: "Lucida Grande", "Lucida Sans Unicode", verdana, lucida, arial, sans-serif;}.inlinenotes {background-color: #FFF280; padding: 2px;}.red {color: #ff0000;}.green {color: green;}</style><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Urakawa Project - Software Development Kit - Programmer's Guide / Developer Primer</title></head><body>


[emailDanielWECK]: mailto:daniel.weck@gmail.com "Daniel WECK email"

[wwwDaisyPipeline]: http://www.daisy.org/projects/pipeline/ "www"

[wwwANT]: http://ant.apache.org/ "www"

[wwwGraphviz]: http://www.graphviz.org/

[wwwUMLGraph]: http://www.spinellis.gr/sw/umlgraph/ "www"

[wwwNetbeans]: http://www.netbeans.org/ "www"
[wwwEclipse]: http://www.eclipse.org/ "www"

[wwwIntelliJ]: http://www.jetbrains.com/ "www"

[wwwW3C-SMIL]: http://www.w3.org/AudioVideo/ "Synchronized Multimedia Integration Language - W3C homepage"
[wwwSMILRec]: http://www.w3.org/TR/SMIL2/ "SMIL W3C Recommendation"

[wwwUrakawaSDKAPIDoc]: http://urakawa.sourceforge.net/sdk/apidoc/ "www"
[wwwUrakawaSDKCSharpDoc]: http://urakawa.sourceforge.net/sdk/APIdoc.zip "www"
[wwwUrakawaUMLDiagrams]: http://urakawa.sourceforge.net/sdk/uml-diagrams/ "www"

[wwwUrakawaDaisyHome]: http://www.daisy.org/projects/urakawa/ "www"

[wwwUrakawaSFHome]: http://urakawa.sourceforge.net/ "www"
[wwwUrakawaObiHome]: http://urakawa.sourceforge.net/obi/ "www"
[wwwUrakawaMirrorDaisyForAll]: http://www.daisy-for-all.org/urakawa-sfmirror/ "www"
[wwwUrakawaMirrorDaisy]: http://www.daisy.org/projects/urakawa/sfmirror/home.html "www"

[wwwUrakawaSFProject]: http://sourceforge.net/projects/urakawa "www"

[wwwUrakawaSVNBrowse]: http://svn.sourceforge.net/viewvc/urakawa/ "www"
[wwwUrakawaSVNBrowseTrunkRoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/ "www"
[wwwUrakawaSVNBrowseArchUMLRoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/architecture/ "www"
[wwwUrakawaSVNBrowseArchJavaRoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/architecture/UMLGraph/src/org/daisy/urakawa/ "www"

[wwwUrakawaSVNBrowseArchIDEARoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/architecture/UMLGraph/ "www"

[wwwUrakawaSVNGuide]: http://sourceforge.net/svn/?group_id=149942 "www"

[wwwLGPL]: http://www.gnu.org/licenses/lgpl.html "www"

[wwwDublinCore]: http://dublincore.org/ "www"

-------------------

# The Urakawa Project
## Application Programming Interface / Software Development Kit
### Implementor's Guide / Developer Primer

_Author/Editor_ : [__Daniel WECK__][emailDanielWECK]  
_Last revision_ : __2007 August 06__

-------------------

# Table of Contents

1. [Introduction][]
  1. [Goal][]
  - [Project Organization][]
  - [UML Documentation][]
- [Key Concepts][]
 1. [Data Model Genericity][]
 - [Object Model Generalities][]
 - [Persistence with XUK][]
 - [Object Creation using Factories][]
 - [Condition Checking and Exceptions][]
- [Model Structure][]
 1. [Core][]
  1. [Events][]
 - [Commands][]
 - [Exceptions][]
 - [Metadata][]
 - [Navigator][]
 - [XUK][]
 - [Validation][]
 - [Properties][]
 - [Media][]
  1. [Timing][]
  - [Utilities][]
 - [Examples][]
- [Glossary of Terms][]

-------------------

# Introduction

## Goal

The intended audience for this document is:

* designers / modelers of the SDK's data model and facade API.
* implementors of the Urakawa SDK (e.g. C++, Java, C#).
* application developers of software tools using / based-on the SDK.

The purpose of this manual is to:

* present a high-level architecture of the SDK data model.
* provide guidance for software programmers, in particular to facilitate application programming ("how to use the SDK").

This guide is __not__ a replacement for the "[API-doc][wwwUrakawaSDKAPIDoc]", which remains the recommended programmer's reference. Additional [UML class-diagrams][wwwUrakawaUMLDiagrams] offer some reading convenience (Unified Modeling Language).

This guide does __not__ provide information for language-specific SDK implementations. Instead, it describes the generic language-independent object-oriented model of the SDK. The SDK design is normally implemented as-is, modulo any language-specific optimizations. For implementation-specific details, please refer to the appropriate documentation (e.g. [C# SDK doc][wwwUrakawaSDKCSharpDoc]).

## Project Organization

The [Urakawa project][wwwUrakawaSFHome] (mirror available [here][wwwUrakawaMirrorDaisyForAll]) specifies an object-oriented __API__ (Application Programming Interface) and currently provides a reference implementation written in C# (__SDK__, Software Development Toolkit). A C++ reference SDK implementation is planned, please consult the website for more information.

The Urakawa project also hosts software applications that rely on the functionality provided by the SDK. __[Obi][wwwUrakawaObiHome]__ is a Daisy authoring tool (for audio NCX-only books). __Tobi__, a new software project that will become public soon, will also be based on the Urakawa SDK. It will facilitate authoring of full-text full-audio DTB (digital talking books).

All of the Urakawa project deliverables are published under an [open-source license][wwwLGPL]. Developers are strongly encouraged to checkout the project source code using Sourceforge's [SVN project repository][wwwUrakawaSVNGuide] (Subversion source code version control). Immediate online viewing is also available through the [SVN browser][wwwUrakawaSVNBrowse].

To reflect the aforementioned deliverables, the Urakawa project is conveniently divided into 3 main activities:

- "Architecture" => the SDK design (data model and facade API)
- "Implementation" => the SDK reference-implementation (currently C#)
- "Application" => a show-case application (currently Obi, later Tobi)

The source code and documents associated to these 3 modules are available in the SVN repository, in [distinct locations][wwwUrakawaSVNBrowseTrunkRoot] identified by their names.

In the present document, we will focus on the Architecture part of the project, for which the main deliverables (other than the present document) are essentially a set of UML class diagrams and a thoroughly documented abstract API.

## UML Documentation

The SDK's data model and facade API are specified in an Object-Oriented (OO) fashion. UML class diagrams are used to present the architecture of the software design.

The UML diagrams are [distributed][wwwUrakawaSVNBrowseArchUMLRoot] in the PNG image format, and are designed primarily to be viewed on the screen, and optionally to be printed-out on paper.

The UML diagrams are built using a plain-text declarative format. The design is therefore accessible to blind and visually impaired users. This source material is in fact plain Java code, augmented with special annotations used for generating the set of UML diagrams. Developers will probably prefer to work with the source code directly, rather than looking at static UML images. Please consult the [SVN repository][wwwUrakawaSVNBrowseArchJavaRoot] for more information.

Java was chosen as the declarative form of the UML diagrams, because of its strong focus on OOP (Object-Oriented Programming). However, the SDK design is not Java-only or Java-centric ! Any language that supports OOP can be used to implement the SDK. Language-specific optimizations and OO concepts can be used to taylor the implementation for a particular user-group.

There are very good IDEs (Integrated Development Environment) for the Java programming language, so the SDK design is very easy to write and navigate. 

Another benefit from using a declarative text format for the UML diagrams (instead of raw, flat images) is that the source material can be included under version control (e.g. SVN Subversion or CVS).As a result, the history of changes can be viewed using the standard "diff" tools, and updates can easily be reverted.

The UML diagrams production process involves a special parser for the Java sources, called [UMLGraph][wwwUMLGraph]. This tool produces "dot" files (plain-text declarative graph format) which are then interpreted by [Graphviz][wwwGraphviz] to output a variety of formats (PNG, PDF, HTML image maps, etc.). In order to supply detailed UML entity information, special UMLGraph annotations are used in the source Java code (in addition to the standard JavaDoc comment tags). The full process is implemented using the [ANT][wwwANT] makefile format, see the ["build.xml" file][wwwUrakawaSVNBrowseArchIDEARoot].

-------------------

# Key Concepts

## Data Model Genericity

Initially, the Urakawa project targets in priority DTB (Digital Talking Book) formats (e.g. Daisy), but the SDK potentially meets the requirements of many other use-cases, such as accessible motion pictures, general SMIL authoring, etc.

The data model provides a structure for generic multimedia presentations, in a modular and extensible way, to enable a variety of application domains. The API is not based on a specific authoring scenario, instead it provides a generic framework for manipulating multimedia documents.

Multimedia presentations based on the Urakawa data model are highly-structured documents, based on a central tree which supports enhanced navigation, timing, metadata, media objects (etc.), as well as custom (application-defined) constructs.

The approach used to implement such extensibility is to expose a generic document tree for which nodes can have a number of object "annotations" or "properties".

For example: a given tree node in the document is the structural equivalent of a "h1" HTML header, hosts an audio file for the human narration of the h1 text label, and is a navigable access point for the document's table of content. At authoring time, such h1 title may require further work by the document author, so an interesting edition facility is to have "todo" annotations inside the document tree which can be conveniently exposed in a dedicated UI view. In this case, an application-defined todo property can be attached to our h1 example node, via the extension mechanism provided by the underlying SDK. Generally speaking, any kind of data can be attached to a document tree.

## Object Model Generalities

The SDK design makes extensive use of interfaces to describe the object-oriented architecture. Interfaces provide service description (via a set of methods) as opposed to describing instance containers. They allow greater flexibility in respect to multiple inheritance (some languages do not support multiple inheritance, others do). W3C DOM is a prime example of the pervasive use of interfaces. IDL (Interface Definition Language) is also representative of the benefits of abstraction.

Concrete classes are often named "*Impl" (e.g. TreeNodeImpl), and have an equivalent base interface (e.g. TreeNode). This is because the SDK uses the factory design pattern to generate instances, in order to facilitate round-trip serialization into the Urakawa XML format (XUK). For more information, please refer to the appropriate sections in this document. Generally-speaking, a base interface can have several concrete implementations for which instances can be generated transparently by the factory methods. By default, the SDK provides single implementations but applications can extend this behaviour to meet their requirements (e.g. TreeNodeMobileDeviceImpl vs TreeNodeWebServerImpl).

Abstract classes are used when we explicitly want to limit the application developer's capacity to extend the design (in the object inheritance sense).

Interfaces cannot specify composition or aggregation relationships (in the UML "association" sense), but the SDK design uses a special UML notation to describe these relationships at the interface level (instead of at the level of the concrete classes). The motivation for this non-UML-standard addition is simply that *Impl concrete classes are usually not easy to read, because of the number of methods they contain. By placing the relationships at the level of the base interfaces, the Urakawa software design is a lot easier to understand and navigate. The resulting UML diagrams also benefit from the improved readability.

The Urakawa SDK (data model and API) is geared towards providing a clear design contract. Programming by contract not only facilitates unit-testing, it also removes ambiguities and clarifies expectations for developer teams.

For example, the Urakawa SDK design incorporates thorough checks of the values of method parameters. The assert conditions are described using checked exceptions for reading convenience, but of course strict implementation do not actually have to use exceptions at all (see the related chapter in the present document). The objective is to provide enough safeguards for preventing obvious (unfortunately common) implementation bugs.

UML associations such as aggregation and composition are extremely useful. They are an integral part of the design contract, by describing ownership relationship between object instances. This is useful information for implementations in languages that require manual memory handling (as opposed to virtual-machine-based, managed languages like Java and C#, with automatic garbage collection). For example, a C++ reference implementation must explicitly manage memory allocation (object ref-counting, etc.) to guarantee object integrity and prevent memory leaks.

## Persistence with XUK

The Urakawa SDK is based on a data model with native support for serialization in an XML format, called XUK. This provides authoring applications with a built-in mechanism ("out-of-the-box") for document persistence and allows for loss-less round-trip open/save operations.

XUK is an XML format for which the schema (grammar) is dependent on the application that uses the SDK (applications are likely to extend the default document model provided by the SDK). XML namespaces are used to distinguish between the default SDK serializable objects, and the custom application-specific types.

The "Xukable" interface is implemented by any object type that is serializable into the XUK format.

Support for importing and exporting other mainstream multimedia formats (e.g. Daisy, SMIL) is possible by converting to and from the XUK format. This is however out of scope for the SDK itself, so this functionality must be provided by third-party modules. The [Daisy Pipeline][wwwDaisyPipeline] provides transformers for many multimedia document types, and there are plans to develop support for the XUK format.

## Object Creation using Factoryories

The Urakawa API makes extensive use of factories for generating object instances (Factory Design Pattern).

This design choice stems from the requirements of round-trip serialization into the Urakawa XML format (XUK). A factory is able to generate an object instance based on a given type, specified by a fully qualified name (in the XML sense). As such, there is a direct mapping between element names in a XUK instance and object types in the data model.

Generally-speaking, a base interface can have several concrete implementations for which instances can be generated transparently by the factory methods. For example:
* TreeNode => base interface
* TreeNodeImpl => concrete implementation
* TreeNode TreeNodeFactory.createTreeNode(QName) => factory method

By default, the SDK provides single implementations but applications can extend this behaviour to meet their requirements (e.g. TreeNodeMobileDeviceImpl vs TreeNodeWebServerImpl).The default factories provided by the SDK can also be extended to support application-specific types.

As a result of this, not much emphasis is put on constructors in the SDK design. Instead, a fully constructed object is the result of its creation (using the factory) and of its initialization (by setting some required attributes). However, actual implementations may choose to expose constructors that take as many parameters as necessary to realize both creation and initialization at the same time (factory methods may also include more initialization parameters than specified in the design).

In fact, the whole initialization phase is a design-specific approach which is materialized my explicit setters (with matching getters). These methods tend to clutter the design, so for reading convenience they are usually extracted in a separate interface named "With*" (e.g. WithQualifiedName). Languages like C# provide native support for class attributes get and set methods, so implementors may choose not to expose explicit getters and setters. If so, special care should be taken to assert the conditions expressed in the SDK design (e.g. setName(String) "cannot pass a null or empty string value").

## Condition Checking and Exceptions


Generally-speaking, exceptions should never be used for controlling the execution flow. The exceptions used in the Urakawa SDK design describe conditions for method input parameter values (e.g. boundaries for integers, null pointers, empty string values, etc.).

This is convenient for defining the implementation contract, but it does not mean that implementations have to use actual checked exceptions (they tend to have a negative impact on performance and require explicit try/catch/finally control structures). Instead, implementations may decide to use unchecked exceptions (ideal, as they generate full stack-trace reports), HRESULT values (very portable), or may choose not to return an error at all. The later is however not recommended, as asserting method parameter values can eliminate a great number of bugs, which are often difficult to trace if no adequate safeguard is implemented.

The UML class diagrams include a special annotation to visually represent the assertions on method parameter values.

-------------------

# Model Structure

The UML class diagrams (PNG images) are divided into several groups, mainly for visual clarity. The aim is to provide a printable form of the model, for quick reference.

On the other hand, the Java source code is structured hierarchically, using the standard Java "packages". Each package corresponds to a physical folder, which encapsulates related concepts. The [Java source code][wwwUrakawaSVNBrowseArchJavaRoot] is easy to browse and provides a very good view of the API's object-oriented model. Any decent Java class browser should provide a nice structured tree-view to navigate the data model.

"_org.daisy.urakawa_" is the root package (or "namespace") of the project. It contains the main object definitions which can be directly used to host a multimedia document and author it. These top-level definitions basically combine and/or inherit the functionality of finer-scoped object types defined throughout the model hierarchy.

## Core

"_org.daisy.urakawa.core_": this part of the data model encapsulates the essential feature set of the toolkit. This means that this is the minimum amount of functionality an application developer is expected to use.

In this limited world, a multimedia presentation (see "CorePresentation*") is made of a generic tree (see "CoreNode*") which supports annotations (see "_core.property_"). It is the "property" part of the data model which really gives the tree some semantics (multimedia features), and therefore it is essential. Later in this guide, the default "properties" provided by the toolkit will be explained.

Additionally, the core tree is by default navigable using the "visitor pattern", a well-known method for accessing and processing nodes of a tree structure (see  "_core.visitor_").

### Events

"_org.daisy.urakawa.core.event_": this part of the design is an application of the Event Listener Pattern, which provides application developers with a framework for handling change-events that occur in the main presentation tree. In the context of MVC (Model-View-Controler) user-interfaces, the ability to capture data model changes is paramount.

## Commands

"_org.daisy.urakawa.commands_": currently under review, this part of the data model is used to specify the "command pattern" for operations on the multimedia tree. This allows for an easily extensible undo-redo framework.

## Exceptions

"_org.daisy.urakawa.exceptions_": this is where ALL of the model exceptions are defined, regardless of where they are actually used.

## Metadata

"_org.daisy.urakawa.metadata_": a simple model for describing project metadata, designed to be compatible with Daisy metadata and inspired by the [Dublin Core][wwwDublinCore] model.

## Navigator

"_org.daisy.urakawa.navigator_": in large multimedia presentations (like Daisy books), browsing the tree using the conventional tree parsing methods quickly becomes overkill, with lots of boiler-plate code. The "navigator" design allows for abstracting the inherent tree complexity based on specific selection criteria, which filter the real tree and produces and "virtual" tree, much smaller and easier to navigate.

## XUK

"_org.daisy.urakawa.xuk_": the essential (de-)serialization in XUK XML format, which allows for storing the data model in a persistent form. The local-name + namespace association ("fully-qualified name") is an key design choice to identify parts of the format. It allows factories to match names with actual object types in the data model, which makes (de-)serialization possible.

## Validation

"_org.daisy.urakawa.validation_": currently under review, this module aims at providing a framework for validating content as it is authored. The objective is mainly preemptive validation, that is to say before the actual operation is performed (e.g. this can be used for ensuring GUI affordance).

## Properties

"_org.daisy.urakawa.properties_": this is the part of the design that gives the tree actual content to work with. It defines the types of annotations that are provided in the default toolkit implementation, baring in mind that this is an extensible mechanism. Currently there are 2 types of properties:

### XML

"_org.daisy.urakawa.properties.xml_": this allows for storing XML information in the tree. This is typically used to represent DTBook content from Daisy books.

### Channel

"_org.daisy.urakawa.properties.channel_": the notion of channel encapsulates the concept of semantically-related multimedia content. For example, within a multimedia presentation, there is an audio stream in English which can be switched dynamically to French. These 2 audio channels are stored separately by the data model, and can be synchronized, extracted, manipulated independently.

During the authoring process, synchronization can be performed adequately. During the generation of content in specific distribution formats (e.g. SMIL or Daisy), the notion of channel is lost in favor of a "cooked" or "flat" structure (easier to interpret by playback applications, and more streamable). The concept of channel is therefore a semantic construct which essentially helps encapsulating content to serve the authoring process.

Channels need to be managed in the sense that a presentation must know about its existing channel containers. This is the role of "ChannelManager".

## Media

"_org.daisy.urakawa.media_": this part materializes the concept of media objects (audio, video, text, etc.), in a rather abstract form that attempts to hide the underlying storage and encoding capabilities. See for example, the "MediaLocation" entity. In contrast, the "asset" sub-package enters the realm of concrete physical implementation.

### Asset

"_org.daisy.urakawa.media.asset_": the term "asset" refers to a physical representation of the media object (file/stream), that uses specific encodings for storage/distribution purposes. Because of the inherent memory implications, such assets need to be managed, thus the corresponding "MediaAssetManager".

### Timing

"_org.daisy.urakawa.media.timing_": like the name suggests, this part contains the timing-related modules. As the model evolves, this will probably also include synchronization based on user-interaction.

### Utilities

"_org.daisy.urakawa.utilities_": the role of this package is to contain utility functions that support the realization of functionality in other areas of the toolkit, but that are not really part of the data model. For example, audio analysis is categorized as "utility", as the primary goal of the Urakawa toolkit is not to be a full-blown audio/video processing environment.

## Examples

"_org.daisy.urakawa.examples_": this package the data model contains actual implementations that can be compiled and run. This is mainly for demonstration purposes and is not part of the final reference implementations of the toolkit, like the provided C# one.

# Glossary of Terms

<p>For your reference, here is a list of useful acronyms used in this document, in alphabetical order:</p>

<ul>
<ul class="noindent">
	<li><strong><acronym title="Application Programming Interface">API</acronym></strong> (Application Programming Interface)</li>

	<li><strong><acronym title="Digital Talking Books">DTB</acronym></strong> (Digital Talking Books)</li>

	<li><strong><acronym title="Digital Accessible Information SYstem">Daisy</acronym></strong> (Digital Accessible Information SYstem)</li>

	<li><strong><acronym title="Frequently Asked Questions">FAQ</acronym></strong> (Frequently Asked Questions)</li>

	<li><strong><acronym title="National Information Standards Organization">NISO</acronym></strong> (National Information Standards Organization)</li>

	<li><strong><acronym title="Software Development Kit">SDK</acronym></strong> (Software Development Kit)</li>

	<li><strong><acronym title="Synchronized Multimedia Integration Language">SMIL</acronym></strong> (Synchronized Multimedia Integration Language)</li>

	<li><strong><acronym title="Table of Contents">TOC</acronym></strong> (Table of Contents)</li>

	<li><strong><acronym title="Unified Modeling Language">UML</acronym></strong> (Unified Modeling Language)</li>

	<li><strong><acronym title="eXtended Markup Language">XML</acronym></strong> (eXtended Markup Language)</li>

	<li><strong><acronym title="XML for UraKawa">XUK</acronym></strong> (XML for UraKawa)</li>
	<li><strong><acronym title="Object-Oriented Programming">OOP</acronym></strong> (Object-Oriented Programming)</li>
</ul>


</ul>

</div>

-------------------

<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml11" alt="Valid XHTML 1.1" style="border:0;width:88px;height:31px;"/></a><a href="http://jigsaw.w3.org/css-validator/check/referer"><img style="border:0;width:88px;height:31px;" src="http://jigsaw.w3.org/css-validator/images/vcss" alt="Valid CSS"/></a></p>

<div style="height: 600px;">&nbsp;</div>

</body></html>

@designConvenienceInterface see {@link org.daisy.urakawa.DesignConvenienceInterface}
@see org.daisy.urakawa.DesignConvenienceInterface

@leafInterface see {@link org.daisy.urakawa.LeafInterface}
@see org.daisy.urakawa.LeafInterface

@stereotype
Initialize
Language-Dependent
Abstract
OptionalLeafInterface
OptionalDesignConvenienceInterface

/**
 * Abstract factory pattern: from the API user perspective: do not use
 * constructors, use a factory instead (which will delegate to the real
 * constructor of its choice). - A Factory offers much more flexibility than
 * standard constructors. For example, optimized constructors can be used for
 * instanciating many objects at once (e.g. parallel processing). - Another
 * example is to have a memory-efficient object allocator for when instanciating
 * many objects of the same type throught the course of the execution of the
 * program, by always returning the same "Flyweight" instance of the object
 * (e.g. Text media object is likely to created thousands of times in a Daisy
 * book, for each small fragment of text). Implementation of the "Flyweight"
 * pattern are quite common: Dom4J (Namespace object), Swing (TreeRenderer),
 * etc. More info:
 * http://exciton.cs.rice.edu/javaresources/DesignPatterns/FlyweightPattern.htm -
 * This factory may be implemented as a singleton, but this is not a
 * requirement. The implementation can decide what pattern suits it best. - This
 * factory should take care of building certain types of Nodes, characterized by
 * their Property attribute. For example, Daisy nodes should include a
 * ChannelsProperty with audio and text channel, which imply that the channel
 * must be registered by the ChannelsManager beforeHand. This also has
 * implication on what a Validator does for the type of Node created.
 * 
 * 
 */