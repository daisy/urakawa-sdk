Resolved items:

(2) create() factory methods must register new object to the manager, if any.
** Ole: DONE
** Daniel: DONE

6) Verify the mergeWith, split and copy-clipped methods, on AudioMediaData (or its direct container ManagedAudioMedia), on WavClip, and with different return types (Stream, AudioMediaData, etc.).
** Ole: DONE

13-c) Add isManagerOf(uid:string):bool methods to the managers
** Ole: DONE
** Daniel: DONE

31) Have several Presentations per Project
** Daniel: DONE
** Ole: DONE

34) XmlProperty => remove XmlType.
** Daniel: DONE
** Ole: DONE

35) Add "language" attribute to Presentation+Channel+Media
** Daniel: DONE
** Ole: DONE

36) Remove MediaType + Channel.isMediaTypeSupported(MediaType) (replace with Channel.canAccept(Media)) + remove Channel.addSupportedMediaType() + remove MediaTypeIsNotSupportedException + fix SequenceMedia.canAccept(Media) + fix factory createMedia() (for each media type including empty sequence)
OPTIONAL: add TypedSequenceMedia(<Media>)
** Daniel: DONE
** Ole: DONE

46) @Daniel: add ManagedMedia interface:
ManagedAudioMedia implements AudioMedia, ManagedMedia;
** Daniel: DONE
** Ole: DONE

50) Have Property implement WithPresentation
** Ole: DONE
** Daniel: DONE

52) Add int getCount() and void append(ICommand cmd) and List<ICommand> getListOfCommands() methods to CompositeCommand
** Ole: DONE
** Daniel: DONE

54) application access of undo/redo stack content (list of commands) => gives getDescription() to display GUI list for direct selection of undo of redo level
=> adding methods getListOfUndoStackCommands, getListOfRedoStackCommands, getListOfCommandsInCurrentTransaction
** Ole: DONE
** Daniel: DONE

56) In architecture, TreeNodeImpl has a setProperty method that should have been removed in the Property assignment refactoring
** Daniel: DONE

57) Remove XmlProperty.copyXmlProperty and ChannelsProperty.copyChannelsProperty in architecture?
** Daniel: DONE

58) Add method getListOfUsedMediaData to UndoRedoManager that returns a list of all MediaData used by a command associated with the UndoRedoManager via. the undo/redo stacks or via. the currently active transaction
** Ole: DONE
** Daniel: DONE

59) Change IXukAble.XukOut method by adding Uri baseUri parameter. Previously the baseUri of Presentation was used, but this solutions was never clean and works even worse with multiple Presentations per Project.
** Daniel: DONE

60) Rename Presentation.get/setBaseUri to get/setRootUri to avoid confusion with baseUri of XukOut.
** Daniel: DONE

61) Remove Project(bool initialize) + addNewPresentation();
** Ole: DONE

13-a) *Manager.detach*() verify normalize naming convention for Managers (e.g. add/remove). ==> for MediaDataManager, ChannelsManager, DataProviderManager.
For DataProviderManager, the remove methods take a new parameter to specify whether to destroy ("delete") the actual binary resource (e.g File).
** Daniel: DONE (In the current model, DataProviderManager has a detachDataProvider method. Additionally the remove methods does not have delete parameter)
** Ole: DONE

13-b) ChannelsManager.getListOfChannelsByName() ==> rename by removing "ByName"
** Daniel: DONE
** Ole: DONE

17) new package hierarchy: urakawa.media.data.audio.codec instead of urakawa.media.data.codec.audio
urakawa.media.data.audio now contains some audio-specific stuff that should not be mixed with generic stuff in urakawa.media.data
** Daniel: DONE
** Ole: DONE

18-a)
* I would simplify getExecuteShortDescription()/getUnexecuteShortDescription() into a single getShortDescription() function returning a string that is suitable in the contexts of "Undo {short description}" and "Redo {short description}".
** Daniel: DONE
** Ole: DONE

22) Copy tree structure across Presentations/Projects (with different factories, managers, etc.):
** Daniel: DONE
** Ole: DONE

SOLUTION:


TreeNode {

	public virtual TreeNode export(Presentation destPres) throws FactoryCannotCreateTypeException {
		TreeNode newNode = destPres.getTreeNodeFactory().createNode(this.getXukLocalName(), this.getXukNamespace());

		if (newNode = null) { throw new FactoryCannotCreateTypeException() }

			List<Property> props = sourceNode.getListOfProperties();
			foreach (prop in props) {
				Property newProp = prop.export(destPres);
				newNode.addProperty(newProp);
			}
			foreach (childNode in getListOfChildren()) {
				newNode.appendChild(childNode.export(destPres));
			}
			return newNode;

	}
}

Property {
	public virtual Property export(Presentation destPres) throws FactoryCannotCreateTypeException {
		Property prop = destPres.getPropertyFactory().createProperty(this.getXukLocalName(), this.getXukNamespace());

		if (prop = null) { throw new FactoryCannotCreateTypeException() }
		return prop;
	}
}

ChannelsProperty extends Property {
	
	public override Property export(Presentation destPres) throws FactoryCannotCreateTypeException {
		
		ChannelsProperty destProp = (ChannelsProperty) super.export(destPres);
		
		ChannelsManager destManager = destPres.getChannelsManager();
		///ChannelsManager sourceManager = getPresentation.getChannelsManager();

		List<Channel> channels = this.getListOfUsedChannels();
		
		foreach (channel in channels) {	
			
			Channel destChannel = destManager.getEquivalentChannel(channel);
			
			
			if (destChannel == null) {
				destChannel = channel.export(destPres);
				// destManager.add(destChannel); // NO NEED TO DO THIS: because the above export() uses the factory create method, and therefore handles the association of the channel with its manager.
			}
			
			Media media = getMedia(channel);
			Media destMedia = media.export(destPres);

			destProp.setMedia(destChannel, destMedia);
		}
		
		return destProp;
	}
}

Media {
	public Media export(Presentation destPre)throws FactoryCannotCreateTypeException ;
}

ManagedAudioMedia implements ManagedMedia, AudioMedia {
	public Media export(Presentation destPre) throws FactoryCannotCreateTypeException {
		Media destMedia = destPres.getMediaFactory().createMedia(this.getXukLocalName(), this.getXukNamespace());
		if (destMedia = null) {throw new  FactoryCannotCreateTypeException()}
		
		ManagedAudioMedia destManagedMedia = (ManagedAudioMedia)destMedia;
.
		MediaData mediaData = getMediaData();
		MediaData destMediaData = mediadata.export(destPres);
		destManagedMedia.setMediaData(destMediaData);
	}
}


MediaData {
	public MediaData export(Presentation destPre)throws FactoryCannotCreateTypeException;
}

AudioMediaDataAbstractImpl implements MediaData {
	public MediaData export(Presentation destPre)throws FactoryCannotCreateTypeException {
		MediaData destMediaData = destPres.getMediaDataFactory().createMediaData(this.getXukLocalName(), this.getXukNamespace());
		if (destMediaData = null) {throw new  FactoryCannotCreateTypeException()}
		
		AudioMediaDataAbstractImpl destAudioMediaData = (AudioMediaDataAbstractImpl)destMediaData;
		destAudioMediaData.getPCMInfo().setSampleRate(getPCMInfo().getSampleRate());
		... same for noc+bit depth
		Stream dataStream = getAudioData();
		try {
			destAudioMediaData.appendAudioData(dataStream, getDuration());
		} finally {
			dataStream.close();
		}
	}
}

ChannelsManager {
	public Channel getEquivalentChannel(Channel sourceChannel) {
		foreach (thisChannel in getListOfChannels()) {
			if (thisChannel.isEquivalentTo(sourceChannel)) {return thisChannel;}
		}
		return null;
	}
}

Channel {
	public virtual boolean isEquivalentTo(Channel otherChannel) {
		if (!otherChannel.isSameTypeOf(this)) {return false;} // ZZ1
		if (otherChannel.getName() != getName()) {return false;}
		return true;
	}
}
	DanielChannel {
		Date mDate;
		
		public override boolean isEquivalentTo(Channel otherChannel) {
			
			if (! super.isEquivalent()) {return false;}
			
			DanielChannel ch = (DanielChannel)otherChannel; // Guaranteed to work because of line ZZ1 above
			if (ch.getDate() != getDate()) {return false;}
			return true;
		}
	}


	DateNode extends TreeNode {
		Date mDate;
		public override TreeNode export(Presentation destPres) throws FactoryCannotCreateTypeException {
			TreeNode newNode = super.export(destPres);
			if (! newNode instanceof this.getClass()) {
				throw new FactoryCannotCreateTypeException();
			}
			DateNode actualNode = (DateNode) newNode;
			actualNode.setDate(mDate);
			// etc...
			return actualNode;
		}
	}

Presentation {

static main(args) {
	Presentation presA;
	Presentation presB;
	
	TreeNode importedNode = presB.getRootNode().export(presA);
	
	presA.setRootNode(importedNode);
	// OR:
	presA.getRootNode().appendChild(importedNode);
}
}

29) Should the Undo-Redo Manager be stored in XUK ? (Command and UndoRedoStackManager Xukable)
It would be good, because chunks of audio maintained for example by the MediaDataManager must be kept "alive" while there is a possibility to undo an operation. Obviously if the undo-redo history is flushed, then the corresponding data can be freed. If a user closes a project, the data stays in the directory anyway, so it would be a shame not to save the undo-redo-history in the XUK. BEWARE: a "cleanup" operation must NOT delete data that's still bound to a Command in the undo-redo manager.
** Daniel: DONE
** Ole: DONE

30) Move metadata to presentation
** Daniel: DONE
** Ole: DONE

33) SDK 2.x fundamental change = several properties of the same type per TreeNode. We want to move this to 1.0 while there is only one user base (Obi). Then we remove the issues of backward compatibility.
** Daniel: DONE
** Ole: DONE

Property {
	+ boolean canBeAddedTo(TreeNode);
}

Property prop1 = Factory.create();
TreeNode tree1;
TreeNode tree2;

TODO: check ownership !
tree1.addProperty(prop1); // from then on, prop1 belongs to tree1
tree2.addProperty(prop1); // prop1 is already "owned" so this raises an exception

FlagProperty extends Property {+String}


ErrorProperty extends AnnotationProperty
WarningProperty extends AnnotationProperty

List<T> = TreeNode.getListOfProperties(T);

List<FlagProperty> = TreeNode.getListOfProperties(<FlagProperty>);

List<ErrorProperty> = TreeNode.getListOfProperties(<ErrorProperty>);
List<WarningProperty> = TreeNode.getListOfProperties(<WarningProperty>);

List<ChannelsProperty> = TreeNode.getListOfProperties(<ChannelsProperty>);
==> the list, by design, only has 1 element.

typeof(Type)
Type.class

WarningProperty = TreeNode.getProperty(<WarningProperty>);
==> returns one amongst the list, random one (not guaranteed to be the first, whatever)

List<Property> = TreeNode.getListOfProperties();

TreeNode.addProperty(Property);
TreeNode.addProperties(List<Property>);

TreeNode.removeProperty(Property);
List<Property> = TreeNode.removeProperties(<Property>);
TreeNode.removeProperties();.

TreeNode.hasProperties(<Property>);
TreeNode.hasProperty(Property);
TreeNode.hasProperties();

37) move org.daisy.urakawa.core.property to org.daisy.urakawa
	move org.daisy.urakawa.properties.* to org.daisy.urakawa.property.*
** Daniel: DONE
** Ole: DONE

39) Command: getListOfUsedMediaData() (for cleanup)
** Daniel: DONE
** Ole: DONE

43) Fix ManagedMedia->composition->MediaData + MediaData->Composition->DataProvider
** Daniel: DONE
** Ole: DONE - nothing to do in impl.

44) ImageMedia rename to ExternalImageMedia
** Daniel: DONE
** Ole: DONE

45) replace ChannelFactory.create(String name) with ChannelFactory.create()
** Daniel: DONE
** Ole: DONE

53) Remove automatic command ? (TBD => next Skype call)
APPLICATION
isURManActive() == true

{
TreeNode.append(TreeNode) => URMan.execute(Command)

CompositeCommand com = new ...;
URMan.execute(com)

TreeNode.remove(TreeNode) => URMan.execute(Command)

AUTOMATIC:

SwapNodesCommand:iCommand com = {

CompositeCommand cc = null;

EXECUTE()
URMan.startTrans()
detach()
insert()
detach()
insert()
cc = URMan.endTrans()
return cc;

UN-EXECUTE()
cc.unexecute()

}

UndoRedoMan.execute(com)
=> delegate call to delegateCom = com.execute()
=> if (delegateCom != null) undo-stack.push(delegateCom)

UndoRedoMan.undo()
=> com = undo-stack.pop()
=> delegate call to com.un-execute()
=> redo-stack.push(com)

MANUAL:

SwapNodesCommand:iCommand com = 
EXECUTE()
detach()
insert()
detach()
insert()
}

or:

SwapNodesCommand:iCompositeCommand com = 
com.add(detachCom)
com.add(insertCom)
com.add(detachCom)
com.add(insertCom);
URMan.execute(com)
}

or:

URMan.startTrans()
URMan.execute(detachCom)
URMan.execute(insertCom)
URMan.execute(detachCom)
URMan.execute(insertCom)
URMan.endTrans()

