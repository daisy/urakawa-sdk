<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11-flat.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US"><head><style type="text/css">table thead tr th{padding:0.3em;background-color:#eeeeee;border-bottom:2px #cccccc solid;}table tbody tr td,table thead tr td{padding:0.3em;border-bottom:1px #cccccc solid;}table{border:1px #cccccc solid;}.pay{border:2px orange solid;color:#333333;padding:0.3em;background-color: #FFF28f}.red{color:red;}h4{color:black;padding:0.3em;border:3px #D7DEBD solid;}h3{padding:0.3em;border:1px #666666 solid;background-color:#D7DEBD;}h2{border:2px #333333 solid;background-color:#cccccc;padding:0.3em;}h1,h2,h3,h4{font-family:verdana}body{padding:1em;background-color:#ffffff;color:#333333;font-size:1.11em;font-family:"Lucida Grande",verdana,lucida,"Lucida Sans Unicode",arial,sans-serif;}.framed{color:black;border:3px #FFFF52 solid;background-color: #FFFFCC;margin:1em;padding:1em;font-size:1em;}ul li{margin-bottom:0.5em;}</style><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><title>The Urakawa Project - Software Development Kit (SDK) - Reference Guide for the Data Model and Application Programmer Interface</title></head><body>

[emailDanielWECK]: mailto:daniel.weck@gmail.com "Daniel WECK email"

[wwwDaisyPipeline]: http://www.daisy.org/projects/pipeline/ "www"

[wwwTobiHome]: http://daisy-trac.cvsdude.com/tobi "www"

[wwwANT]: http://ant.apache.org/ "www"

[wwwGraphviz]: http://www.graphviz.org/

[wwwUMLGraph]: http://www.spinellis.gr/sw/umlgraph/ "www"

[wwwNetbeans]: http://www.netbeans.org/ "www"
[wwwEclipse]: http://www.eclipse.org/ "www"

[wwwIntelliJ]: http://www.jetbrains.com/ "www"

[wwwW3C-SMIL]: http://www.w3.org/AudioVideo/ "Synchronized Multimedia Integration Language - W3C homepage"
[wwwSMILRec]: http://www.w3.org/TR/SMIL2/ "SMIL W3C Recommendation"

[wwwUrakawaSDKAPIDoc]: http://urakawa.sourceforge.net/sdk/apidoc/ "www"
[wwwUrakawaSDKCSharpDoc]: http://urakawa.sourceforge.net/sdk/APIdoc.zip "www"
[wwwUrakawaUMLDiagrams]: http://urakawa.sourceforge.net/sdk/uml-diagrams/ "www"

[wwwUrakawaDaisyHome]: http://www.daisy.org/projects/urakawa/ "www"

[wwwUrakawaSFHome]: http://urakawa.sourceforge.net/ "www"
[wwwUrakawaObiHome]: http://urakawa.sourceforge.net/obi/ "www"
[wwwUrakawaMirrorDaisyForAll]: http://www.daisy-for-all.org/urakawa-sfmirror/ "www"
[wwwUrakawaMirrorDaisy]: http://www.daisy.org/projects/urakawa/sfmirror/home.html "www"

[wwwUrakawaSFProject]: http://sourceforge.net/projects/urakawa "www"

[wwwUrakawaSVNBrowse]: http://svn.sourceforge.net/viewvc/urakawa/ "www"
[wwwUrakawaSVNBrowseTrunkRoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/ "www"
[wwwUrakawaSVNBrowseArchUMLRoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/architecture/ "www"
[wwwUrakawaSVNBrowseArchJavaRoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/architecture/UMLGraph/src/org/daisy/urakawa/ "www"

[wwwUrakawaSVNBrowseArchIDEARoot]: http://svn.sourceforge.net/viewvc/urakawa/trunk/urakawa/architecture/UMLGraph/ "www"

[wwwUrakawaSVNGuide]: http://sourceforge.net/svn/?group_id=149942 "www"

[wwwLGPL]: http://www.gnu.org/licenses/lgpl.html "www"

[wwwDublinCore]: http://dublincore.org/ "www"

-------------------

# The Urakawa Project, Software Development Kit (SDK)
# Reference Guide for the Data Model and Application Programmer Interface

_Author/Editor_ : [__Daniel WECK__][emailDanielWECK]  
_Last revision_ : __2008 January 22__

-------------------

# Table of Contents

1. [Introduction][]
  1. [Project Organization][]
  - [Intended Purpose][]
  - [Java and UML][]
- [Key Concepts][]
 1. [Data Model Genericity][]
 - [How to read the Data Model][]
 - [Persistence with XUK][]
 - [Object Creation using Factories][]
 - [Condition Checking and Exceptions][]
- [Model Hierarchy][]
 1. [Core][]
  1. [Navigation][]
  - [Events][]
 - [Commands, Undo-Redo][]
 - [Exceptions][]
 - [Metadata][]
 - [Navigator][]
 - [XUK][]
 - [Properties][]
  1. [XML][]
  - [Channel][]
 - [Media][]
  1. [Media Data][]
  - [Timing][]
 - [Examples][]
- [Glossary of Terms][]

-------------------

## Introduction

### Project Organization

The [Urakawa project][wwwUrakawaSFHome] is an incubator for a number of open-source software deliverables, published under the business-friendly [LGPL license][wwwLGPL] (Lesser General Public License).

The primary outcome of the Urakawa project is the SDK (Software Development Toolkit), which can basically be seen as the combination of:

* an Object-Oriented authoring __Data Model__ for accessible multimedia
* an __API__ (Application Programming Interface) for this data model

The SDK is specified using the Java programming language, essentially because:

* it is an easy-to-read object-oriented language, with a world-wide popularity
* the Java world probably benefits from the best IDEs (Integrated Development Environments), which makes the specification-writing tasks a lot easier (i.e. refactoring, model navigation, etc.)

The Urakawa project provides a concrete reference implementation of the SDK, written in the cross-platform C# language (although is being tested under Microsoft Windows only, it has been compiled successfully under Mono).

The Urakawa project also incubates 2 major applications based on the SDK:

* __[Obi][wwwUrakawaObiHome]__ is a DAISY authoring tool for audio-only DTBs (Digital Talking Books). It started as a demonstration application for the SDK, but the decision was made to support its development as a full-fledge editor with an important slot in the DAISY production market-place. It is of-course open-source and is written in C#.NET (Microsoft Windows-only)
* __[Tobi][wwwTobiHome]__ is a DAISY authoring tool for full-text full-audio DTBs, including support for Braille, SVG and more. This application is in inception stage at the time of writing this document, and the codename "Tobi" will eventually be dropped in favor of an official one.

Developers are strongly encouraged to checkout the project source code using Sourceforge's [SVN project repository][wwwUrakawaSVNGuide] (SubVersioN). For a quick look, an up-to-date online repository browser is also available [here][wwwUrakawaSVNBrowse].

To reflect the aforementioned deliverables, the Urakawa project is conveniently divided into 3 main activities, each of which lives in a [distinct SVN directory][wwwUrakawaSVNBrowseTrunkRoot]:

- "Architecture" => the SDK abstract design (Data Model and API)
- "Implementation" => the SDK C# reference-implementation
- "Application" => application based on the SDK: Obi (Tobi lives in a separate server due to adjustments in the hosting strategy)

In this present document, we will focus on the _Architecture_ part of the project. The reader is invited to check out the corresponding SVN directory, which should contain the documentation of the abstract API:

 * the source code JavaDoc comments (see *.java files)
 * the equivalent (generated) [HTML API-doc][wwwUrakawaSDKAPIDoc]
 * the convenient [UML class-diagrams][wwwUrakawaUMLDiagrams] (Unified Modeling Language)

### Intended Purpose

The expected audience for this present document is:

* architects of the Urakawa SDK's Data Model and API.
* implementors of the Urakawa SDK (e.g. C# toolkit programmers / contributors).
* developers of software applications based on the SDK should also read this guide, however they are strongly advised to refer to the language-specific documentation (e.g. the C# API-doc).

This reference guide is designed to complement (i.e. not to replace) the abstract API documentation, in order to help the reader understanding the "big picture":

* a high-level overview of the SDK Data Model.
* a "plain-english" description of the API architecture.

Although the formal SDK specifications are written in the Java language, please bare in mind that the emphasis is on describing a generic (language-agnostic) object-oriented model. This guide therefore documents commonly-accepted design patterns, not language-specific features or optimizations.

As a result, this guide does not provide information related to language-specific SDK implementations. If you are developing an application in a existing supported programming language, please also refer to the appropriate documentation (e.g. the [C#-specific API-doc][wwwUrakawaSDKCSharpDoc]).

### Java and UML

The SDK's Data Model and API are specified in an Object-Oriented fashion. A set of UML class diagrams is provided to conveniently represent the most relevant modules of the software architecture.

Java was chosen as the declarative form for the abstract Object-Oriented architecture, not as a usable implementation of the SDK. Any programming language that supports OOP (Object-Oriented Programming) should be suitable for implementing a concrete version of the SDK, and some language-specific optimizations are likely to happen. The Urakawa project's own C# SDK implementation illustrates such possible optimizations (i.e. native events, generics, etc.).

The UML diagrams are [distributed][wwwUrakawaSVNBrowseArchUMLRoot] in the PNG image format, and are designed primarily to be viewed on a computer display, and optionally to be printed-out on paper. The UML diagrams are not drawn manually: they are generated automatically from a plain-text declarative format, which is the Java source code itself. The software architecture is therefore accessible to blind and visually-impaired users, using screen-readers.

The source material for the UML diagrams is Java code augmented with special annotations that are placed in the JavaDoc comments (primarily for configuring the UML generation process). Programmers who do not like reading UML diagrams will feel more at ease reading the [Java source code][wwwUrakawaSVNBrowseArchJavaRoot] directly, using their favorite IDE or editor.

The process that generates the UML diagrams involves a special parser for the Java sources, called [UMLGraph][wwwUMLGraph]. This tool produces "dot" files (plain-text declarative graph format) which are then interpreted by [Graphviz][wwwGraphviz] to output a variety of formats (PNG, PDF, HTML image maps, etc.). In order to supply detailed UML entity information, special UMLGraph annotations are used in the source Java code (amongst the standard JavaDoc comments).

The full generation process is implemented using the [ANT][wwwANT] makefile format, see the ["build.xml" file][wwwUrakawaSVNBrowseArchIDEARoot].

## Key Concepts

### Data Model Genericity

#### Overview

Currently, the Urakawa SDK aims at facilitating the authoring of DTBs (Digital Talking Book), like DAISY 2.02  or DAISY 3 (XML DTBook).

However, the SDK provides an abstraction layer that does not depend on any existing standard. In other words, the core authoring Data Model should be future-proof when new versions of the standards are released. Furthermore, DAISY is in fact one specific distribution format. There are other multimedia standards.

The W3C SMIL (Synchronized Multimedia Integration Language), for example, offers the most generic (and by far the most complete) timing model. Although the Urakawa SDK currently supports only a fraction of SMIL, it will grow and evolve into a richer generic multimedia toolkit, with a DAISY-compatible layer to accommodate the specific DTB requirements. The goal is to ultimately support other use-cases than DTBs, such as accessible motion pictures (multilingual text subtitles, audio captioning, table of content, etc.).

To make this possible, the Urakawa Data Model is modular and the API is extensible. Third-party vendors can target a different application domain by implementing Data Model extensions to the core Urakawa SDK, and an API that conveniently exposes the new features.

#### The presentation tree

A multimedia presentation represented in the Urakawa Data Model corresponds to a hierarchical document, architected around a single __core tree__. This logical structure supports enhanced semantic navigation, timing, events, metadata, media objects, etc. via a set of well-defined types that can be attached to its nodes. In other words, the tree itself is totally abstract (somewhat like DOM): behavioral characteristics are applied to the structure by associating "__properties__" to the nodes of the tree.

The SDK provides built-in properties (e.g. to attach an audio and a text media object to a node), but this can be extended very easily to meet specific application requirements (e.g. a "todo" flag to mark nodes that require editing). Custom constructs can be added by third-party developers by subclassing core base classes, and by configuring object factories (more on that later).

So, a presentation is made of a tree of TreeNode objects, and each TreeNode can have one or more Property objects of different types. Here is a simple, concrete example:

- Let's assume that a given tree node in the presentation document is the structural equivalent of a "H1" HTML header: well, an XmlProperty object is attached to the TreeNode to represent the structural semantics of the H1 header.
- The text content of the H1 header is represented as a TextMedia attachment to the TreeNode, in a specialized media channel called "TextChannel" (a ChannelsProperty is actually used as a proxy, more on that later).
- Attached to the TreeNode is also an audio file (e.g. MP3) corresponding to the human narration in English of the "H1" text label. This AudioMedia is attached on this TreeNode via an AudioChannel (more about channels later).
- Also attached is an audio narration in Spanish of the same "H1" title, represented as another AudioMedia instance.
- This "H1" element is a navigable access point to be included in the document's table of content, so it can be marked as such using a custom property type (e.g. NavigationTargetProperty).

Remember, this is an authoring toolkit, so the fact that one TreeNode has 2 AudioMedia instances attached to it does not mean that the audio plays together in parallel. It is simply a the representation of a hierarchical ownership, which can be displayed in an editing environment as 2 separate AudioChannels (and English and a Spanish one). Such authoring tool may then expose a "DAISY export" feature, which would then only publish the user-selected audio language.

Note: the audio clips in this simple example might well be 10mn MP3 files, from which the H1 text occupies only a small subclip (e.g. from 5.6s to 8.6s, total 3s). The Urakawa SDK provides an abstraction layer to physical storage, so that programmer do not have to deal with that directly. More on that later.

### How to read the Data Model

#### Interfaces

The SDK object-oriented architecture is written in Java and makes extensive use of interfaces. It is very similar to how DOM (Document Object Model) is specified, often using the IDL (Interface Definition Language) format.

An interface is essentially an abstract set of methods that can describe either a particular service (re-usable in many concrete classes) or an actual object type definition (like a class, but without code, attributes and constructors). Baring in mind that the interfaces in the Urakawa SDK are not instance containers, they still provide all the information required to establish the facade API to a concrete object type.

Interfaces have many advantages, especially when the aim is to describe a contract rather than to implement the actual behavior. They enable more flexibility in respect to multiple inheritance (some object-oriented programming languages do not support mix-ins, others do).

#### Concrete classes

In the Java code, there is a naming convention for concrete classes: their name ends with "Impl". For example, the TreeNode object definition is actually an interface. There is one (and only one) concrete implementation, called TreeNodeImpl. Because the Java code is not meant to be used as an actual implementation of the toolkit, such "*Impl" class is usually empty, and exists as a place-holder. It simply means that a real implementation (like the C# one) needs to actually implement the interface.

Abstract classes are used specifically to limit the application developer's capacity to extend the design (in the object-oriented single-inheritance sense), and to force the developer to extend the class in order to implement application-level business logic. Obviously, abstract classes usually implement all the boiler-plate code and only require the implementation of key custom behaviour. The naming convention is that the class name ends with "AbstractImpl".

This separation between interface and class has real benefits, notably when using factories to create object instances of a given type. For example, a TreeNodeImpl instance can be create with a TreeNodeFactory, using its createTreeNode() method. What is interesting here is that the create method is declared to return the TreeNode type (which is the abstract interface), not the real TreeNodeImpl object type. This means that the code behind the create method could be transparently changed to return a custom AnotherTreeNodeImpl type, without any visible impact from the user side, because both concrete TreeNodeImpl and AnotherTreeNodeImpl types are guaranteed to realize the same interface: TreeNode. In other words, this functionality is one mechanism to allow pluggable implementations via the use of factories (more on this later). One could imagine that AnotherTreeNodeImpl is an highly-optimized implementation of a TreeNode for low-powered mobile devices (small memory requirements). Such optimized implementation could be provided by a third-party vendor as a drop-in replacement of the built-in TreeNodeImpl SDK implementation, without an change of code on the client side (the SDK API remains exactly the same).

#### Implications for actual implementations

Now, the "Impl" naming convention is likely to be removed in actual implementations for the sake of clarity and simplicity, because such implementations usually provide only 1 single built-in concrete type. This is the case with the C# implementation, where TreeNode is actually a concrete class. Removing the "middle man"  interface obviously removes the benefits of configurable factories, but the justification lies in the fact that this is likely not a paramount design goal for most SDK implementations. Developers can easily identify this type of interfaces, as they are marked with the "@leafInterface" annotation (inside the JavaDoc comment).

On the other hand, there are interfaces which are used in the more traditional way, without a single atomic corresponding implementation but with a use in many host classes. Such interface specifies only a small set of methods that several classes need to implement. They are used to split to design in smaller sub-contracts, or individual component services. They not only provide a reading convenience (useful in IDEs with auto-completion on method signatures), but they are also usable by application programmers for casting object types to a lower common denominator: this increase testability and therefore reduces the risk of bugs. Such interfaces are marked with the "@designConvenienceInterface" annotation, and SDK implementors may choose not to include them in their implementation.

One obvious example of optional interfaces is the "With*" interfaces (e.g. WithProperty). Such naming convention is used for interfaces that contain getters and setters (e.g. Property:getProperty() and void:setProperty(Property obj)). The reason why they are externalized in separate interfaces is that is greatly improves readability of the API specification. Getters and setters often come with native syntactic sugar in objet-oriented languages, such as C#. Java does not have native support for this, and furthermore it makes sense to individually specify the contract for the getter and setter. The extra verbosity is offset to an external interface, but SDK implementations are allowed to ignore this construct.

#### Limitations of interfaces

Because interfaces cannot specify "composition" or "aggregation" relationships (in the UML "association" sense), the SDK design uses a special UML notation to describe these relationships at the interface level (instead of at the level of the concrete classes). The motivation for this non-UML-standard addition is simply that "Impl" concrete classes are usually not easy to read, because of the great number of methods they potentially contain. Given that the effectiveness of the SDK specification resides in its clarity, it makes sense to use the interfaces as first-class citizens of the object-model, as they are more fine-grained than the larger "Impl" classes. By placing the UML association links at the level of the base interfaces, the Urakawa architecture is a lot easier to read and navigate. The resulting UML diagrams obviously benefits from the improved readability, at the expense of a non-UML standard notation.

#### The contract is everything

The Urakawa SDK (Data Model and API) promotes "programming by contract". This facilitates unit-testing, removes ambiguities and clarifies expectations amongst developer teams. To achieve this:

- the design includes strict checking of the values of method parameters. The assert conditions are described using checked exceptions for reading convenience, but of course implementations do not actually have to use exceptions at all (more on this later). The objective is to promote fail-fast behaviour as much as possible.
- UML associations such as aggregation and composition are extremely useful. They are an integral part of the design contract, as they describe ownership rules between object instances. This is useful information for implementations in languages that require manual memory handling, as opposed to managed-languages (e.g. Java and C#) which execute within the context of a virtual-machine that automatically handles garbage collection. For example, a C++ reference implementation would need to explicitly manage memory allocation and object ref-counting, to guarantee object integrity and prevent memory leaks. the UML associations are the main indicators for how ref-counting should be implemented.

### Persistence with XUK

The Data Model of the Urakawa SDK provides native support for serialization into an XML format called XUK. This offers authoring applications with an "out-of-the-box" mechanism for document persistence, and also allows lossless round-trip open/save operations. The XUK format is pretty much an image of the object-model for anything that is not binary (i.e. audio files are stored as real files in an associated media directory).

XUK uses XML namespaces to distinguish from built-in elements provided by the SDK, and custom extensions defined at the application level. The XML grammar therefore depends on the application domain.

The "Xukable" interface is realized by any object type that is serializable into the XUK format, which is basically most of the classes of the SDK. There are XukIn and XukOut methods, for parsing and serializing, respectively.

Support for importing and exporting other mainstream multimedia formats (e.g. Daisy, SMIL) is possible by converting to and from the XUK format. This is however out of scope for the SDK itself, so this functionality must be provided by third-party modules. A concrete example is Obi which provides its own XSLT-based converter to open and save DAISY content directly. The [Daisy Pipeline][wwwDaisyPipeline] provides transformers for many multimedia document types, and there are plans to develop support for the XUK format.

### Object Creation using Factories

The Urakawa API makes extensive use of factories for generating object instances (it's a widely-adopted Design Pattern).

This design choice stems from the fact that round-trip serialization with the XUK format requires the ability to create object instances based on a XML fully-qualified name. The create methods of a factory therefore make use of the namespace/local-name information to determine the real type of object to generate. As such, there is a direct mapping between element names in a XUK instance and object types in the data model. This mapping is explicitly hard-coded into the factories (native to the SDK, or custom to the application), and is not configurable otherwise.

Sub-classing the default SDK factories allows third-party applications to implement the additional routines required to support custom object types. There is one factory per type of object to create, however there is one special global factory called the DataModelFactory, which role is to produce the individual factories (it is kind of a factory of factories...). This is basically the mechanism that allows applications to override the default SDK factories with their own, at startup when initializing the project.

As a result of this, not much emphasis is put on constructors in the SDK design. Instead, a fully constructed object is the result of its creation (using the factory and a no-arg constructor) followed by its initialization (by setting some required attributes). However, actual implementations may choose to expose constructors that take as many parameters as necessary to realize both creation and initialization at the same time (factory methods may also include more initialization parameters than specified in the design). The setter methods that play a role in initializing object instances are marked with the "@stereotype Initialize" annotation. This stereotype appears in the resulting UML class diagrams as well, so that a reader knows when to expect object initialization.

### Condition Checking and Exceptions

Generally-speaking, exceptions should never be used for controlling the execution flow. The exceptions used in the Urakawa SDK design describe forbidden values for input parameter of methods (e.g. null pointers, empty string values, boundaries for numerals, etc.). The rationale is that fail-first is the most efficient way to prevent bugs due to wrong data input.

This is a convenient mechanism for defining the implementation contract, but it does not mean that implementations have to use actual checked exceptions (they tend to have a negative impact on performance and require explicit try/catch/finally control structures). Instead, implementations may decide to use unchecked exceptions (still useful, as they generate full stack-trace reports), HRESULT output parameter values (very portable), or may choose not to return an error at all. The later is however not recommended, as asserting method parameter values can eliminate a great number of bugs, which are often difficult to trace if no adequate safeguard is implemented.

## Model Hierarchy

### Top-level

"_org.daisy.urakawa_" is the root package (or "namespace") of the project. It contains the top-level object type definitions for an Urakawa multimedia document.

A "Project" can host several "Presentations". Convenient 'open' methods are available to create a "Presentation" instance from a XUK XML file. Alternatively, a whole multimedia document can of course be created from scratch (programmatically).

Each "Presentation" hosts factories for the various object types involved in the data model, as well as providers and managers (see corresponding sections below for more information). The "Presentation" is also the owner of the document tree, made of "TreeNodes" (see the "Core" chapter below).

Please note that the "PropertyFactory" defined at this level of the hierarchy is a wrapper for all the possible property types of the SDK (see the "Property" chapter below).

### Core

"_org.daisy.urakawa.core_": this part of the data model encapsulates the core constructs for the document tree.

A tree made of "TreeNodes" is basically totally generic, it defines a 'blank' hierarchical tree structure. Each node of the tree can host several "Property" objects, which determine the actual content of the tree (see the "Property" chapter below).

#### Navigation

The core tree is navigable using the "visitor pattern", a well-known method for accessing and processing nodes of a tree structure (see  "_core.visitor_").

#### Events

The core tree includes an event mechanism, for when the document instance is modified. The registration and notification processes are based on the subscribe-publish design pattern. Actually, both the Listener and Observer pattern are available in the data model. SDK implementations may choose one or the other, depending on language-specific optimizations (e.g. C# has built-in support for events).  (see  "_core.event_").

### Commands, Undo-Redo

(See the "_org.daisy.urakawa.undo_" SDK namespace)

Support for Undo-Redo is built in the SDK. It is based on a common design practice called the "Command Pattern".

#### Commands

A Command is simply a container for an action, that can be executed once it has been defined (see the execute() method). 

For the purpose of Undo-Redo, a Command can not only be executed, but also undone (see the unExecute() method).

Although Commands are the fundamental underlying mechanism to implement undoable operations, they can be used to encapsulate user actions that are not at all reversible. The canUnExecute() method is used to check wether a Command is reversible.

The getLongDescription() and getLongDescription() methods provide human-friendly descriptions of what the command does. This information is typically used to present the application logic in the user interface. Please note that the provided text must describe the business logic of the execute() method, not of the reversible counterpart unExecute(). See the following paragraph for more information.

#### Undo-Redo

Commands provide the low-level construct to encapsulate a reversible action. In order to maintain the integrity of the data model when performing write operations, the UndoRedoManager registers done and undone Commands in the undo stack and the redo stack, respectively (see the execute() method).

When a non-reversible Command is executed via the UndoRedoManager, the undo and redo stacks get invalidated (flushed), so further calls to undo() and redo() will be unsuccessful. However when a reversible Command is registered via the execute() method, it is pushed onto the undo stack and the redo stack gets flushed.

The undo() and redo() methods can be called to navigate through the history of changes, and their canUndo() and canRedo() peer methods should be used to check wether there is any Command to undo or redo in the current history stacks.

The flushCommands() can be used to clear all done and undone Commands from the stacks. This effectively resets the history and makes it impossible to undo previous changes !

The getRedoShortDescription() and getUndoShortDescription() methods provide access to the description for the next undoable or redoable Command available, if any. This typically delegates to the Command's own getShortDescription() method, so textual descriptions should be judiciously chosen so that a simple prepend of "Undo:" and "Redo:" is self-explicit and non-ambiguous (e.g. "Add a node to the tree.", "Redo: Add a node to the tree.", "Undo: Add a node to the tree.").

This can typically be used to render the undo-redo history in the user interface, and let the user select the level to undo or redo. To achieve this, the getListOfRedoStackCommands() and getListOfUndoStackCommands() methods can be used.

#### Composite Commands

Sometimes, a complex operation on the data model needs to be materialized using several Commands that execute in sequence. However, from the user perspective, such complex operation should be undoable in one go (not for each individual Command).

This is the role of a CompositeCommand. It is actually a sub-type of Command that is used to register a sequence of individual Commands (which can be CompositeCommands, recursively. Therefore, nested CompositeCommands are allowed by this mechanism).

The getShortDescription() and getLongDescription() methods can be set to return a custom human-friendly label, or by default a description will be generated by concatenating each individual Command's description (recursively). It is therefore recommended to use setShortDescription() and setLongDescription() in order to keep the text readable.

Now, instead of manually creating a CompositeCommand object, there is a "Transaction" mechanism built in the UndoRedoManager.

By using startTransaction() to notify the beginning of a lengthy operation, the UndoRedoManager executes any following Commands normally, but waits for a matching call to endTransaction() in order to encapsulate all the registered Commands in a CompositeCommand.

Because CompositeCommands can be nested, Transactions can also be nested, as long as the startTransation() and endTransaction() methods are called in matching pairs.

If the need arise, a Transaction can be terminated prematurely using the cancelTransaction() method. The UndoRedoManager then rolls-back all the affected Commands since the call to startTransaction().

The isTransactionActive() method indicates whether a Transaction is currently active. There are a number of operations that cannot be done while a Transaction is active, such as trying to undo() or redo(). Once Transactions (potentially nested) are completed normally (the last call to endTransaction() matches the first call to startTransaction()), then the system is back to normal and a call to undo() will reverse the finished Transaction. Obviously, cancelTransaction() can also be used to terminate the current operation, rollback the committed Commands, and return to normal.

The getListOfCommandsInCurrentTransactions() method lists Commands that are NOT in the undo stack, because a Transaction places Commands in a temporary state until they are finally committed to the undo stack by using endTransaction().

#### Data Model Persistence, XUK Serialization

The history stack maintained by the UndoRedoManager can be serialized into the XUK XML format. The Commands contained in both the Undo and the Redo stack become persistent, which allows for closing and re-opening a full project while keeping the edition session intact.

#### Custom Commands, Extensibility

In the SDK, Command is actually an abstract interface, which has a concrete implementation called CompositeCommand.

However, because the Data Model is itself extensible, it is necessary to allow application developers to create their own Commands with the business logic that they require.

For example, let's say that an application defines the StringTreeNode class which is an extension of TreeNode, with the added ability to store a descriptive character string (e.g. set/getNodeDescription()). In order for changes to this NodeDescription attribute to be registered in the UndoRedoManager (and therefore to be undoable), a new Command is needed (e.g. TreeNodeDescriptionChangeCommand).

The application developers therefore have the responsibility of writing concrete Command classes that meet the requirements of their application's business logic.

### Exceptions

"_org.daisy.urakawa.exception_": this is where common exceptions are defined. Exception types specifically related to some parts of the data model are located in their corresponding package.

### Metadata

"_org.daisy.urakawa.metadata_": a simple model for describing project metadata, designed to be compatible with Daisy metadata and inspired by the [Dublin Core][wwwDublinCore] model.

### Navigator

"_org.daisy.urakawa.navigator_": in large multimedia presentations (like Daisy books), browsing the tree using the conventional tree parsing methods quickly becomes overkill, with lots of boiler-plate code. The "navigator" design builds an abstraction of the full document tree, based on specific selection (filtering) criteria. The resulting "virtual" tree is much smaller and easier to navigate.

### XUK

"_org.daisy.urakawa.xuk_": (de-)serialization in XUK XML format, which allows for storing the data model in a persistent form.

### Properties

"_org.daisy.urakawa.property_": this actual content of the tree structure. While this is an extensible mechanism, the SDK currently has 2 built-in types of properties:

#### XML

"_org.daisy.urakawa.property.xml_": this allows for storing XML information in the tree. This is typically used to represent DTBook content from Daisy books (similar to XHTML).

#### Channel

"_org.daisy.urakawa.property.channel_": the notion of channel encapsulates the concept of semantically-related multimedia content. For example, within a multimedia presentation, there is an audio stream in English which can be switched dynamically to French. These 2 audio channels are stored separately by the data model, and can be synchronized, extracted, manipulated independently.

During the authoring process, synchronization can be performed adequately. During the generation of content in specific distribution formats (e.g. SMIL or Daisy), the notion of channel is lost in favor of a "cooked" or "flat" structure (easier to interpret by playback applications, and more streamable). The concept of channel is therefore a semantic construct which essentially helps encapsulating content to serve the authoring process.

Channels need to be managed in the sense that a presentation must know about its existing channel containers. This is the role of "ChannelManager".

### Media

"_org.daisy.urakawa.media_": this part materializes the concept of media objects (audio, video, text, etc.), in a rather abstract form that hides the underlying storage and encoding capabilities. By contrast, the "data" sub-package enters the realm of concrete physical implementation.

#### Media Data

"_org.daisy.urakawa.media.data_": refers to a physical representation of the media object (file/stream). Because of the inherent memory implications, such data needs to be managed, thus the corresponding "MediaDataManager".

The "codec" sub-package defines codec-specific processing (e.g. MP3).

#### Timing

"_org.daisy.urakawa.media.timing_": like the name suggests, this part contains the timing-related modules. As the model evolves, this will probably also include synchronization based on user-interaction.

### Examples

"_org.daisy.urakawa.examples_": this package the data model contains actual implementations that can be compiled and run. This is mainly for demonstration purposes and is not part of the final reference implementations of the SDK.

## Glossary of Terms

<p>For your reference, here is a list of useful acronyms used in this document, in alphabetical order:</p>

<ul class="noindent">
	<li><strong><acronym title="Application Programming Interface">API</acronym></strong> (Application Programming Interface)</li>

	<li><strong><acronym title="Digital Talking Books">DTB</acronym></strong> (Digital Talking Books)</li>

	<li><strong><acronym title="Digital Accessible Information SYstem">Daisy</acronym></strong> (Digital Accessible Information SYstem)</li>

	<li><strong><acronym title="Frequently Asked Questions">FAQ</acronym></strong> (Frequently Asked Questions)</li>

	<li><strong><acronym title="National Information Standards Organization">NISO</acronym></strong> (National Information Standards Organization)</li>

	<li><strong><acronym title="Software Development Kit">SDK</acronym></strong> (Software Development Kit)</li>

	<li><strong><acronym title="Synchronized Multimedia Integration Language">SMIL</acronym></strong> (Synchronized Multimedia Integration Language)</li>

	<li><strong><acronym title="Table of Contents">TOC</acronym></strong> (Table of Contents)</li>

	<li><strong><acronym title="Unified Modeling Language">UML</acronym></strong> (Unified Modeling Language)</li>

	<li><strong><acronym title="eXtended Markup Language">XML</acronym></strong> (eXtended Markup Language)</li>

	<li><strong><acronym title="XML for UraKawa">XUK</acronym></strong> (XML for UraKawa)</li>
	<li><strong><acronym title="Object-Oriented Programming">OOP</acronym></strong> (Object-Oriented Programming)</li>
</ul>

-------------------

<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml11" alt="Valid XHTML 1.1" style="border:0;width:88px;height:31px;"/></a><a href="http://jigsaw.w3.org/css-validator/check/referer"><img style="border:0;width:88px;height:31px;" src="http://jigsaw.w3.org/css-validator/images/vcss" alt="Valid CSS"/></a></p>

<div style="height: 600px;">&nbsp;</div>

</body></html>
